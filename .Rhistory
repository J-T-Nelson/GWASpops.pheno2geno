graph_singlePopAlleleFreq(masterTable, SinglePopTable, graph_style = 'point', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 4, sqrtYscale = T, yUpperLim = NA)
graph_singlePopAlleleFreq(masterTable, SinglePopTable, graph_style = 'point', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 4, sqrtYscale = T, yUpperLim = .75)
graph_singlePopAlleleFreq(masterTable, SinglePopTable, numVariants = 15, graph_style = 'point', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 4, sqrtYscale = T, yUpperLim = .75, export = T, file_name = "pointSinglePop_full_options_testExport")
graph_singlePopAlleleFreq(masterTable, SinglePopTable, numVariants = 15, graph_style = 'point', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 1, sqrtYscale = T, yUpperLim = NA, export = T, file_name = "pointSinglePop_full_options_testExport")
graph_singlePopAlleleFreq(masterTable, SinglePopTable, graph_style = 'point', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 1, sqrtYscale = T, yUpperLim = .75, export = T, file_name = "pointSinglePop_full_options_testExport1")
graph_singlePopAlleleFreq(masterTable, SinglePopTable, numVariants = 15, graph_style = 'point', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 1, sqrtYscale = T, yUpperLim = .75, export = T, file_name = "pointSinglePop_full_options_testExport2")
graph_singlePopAlleleFreq(masterTable, SinglePopTable, graph_style = 'bar', facet_graph = F, orderless = F, ascending = F, show_genes =  F, pValAsSize = F, graph_scale = 3, sqrtYscale = F, yUpperLim = NA) #default
graph_singlePopAlleleFreq(masterTable, SinglePopTable, graph_style = 'bar', facet_graph = T, orderless = F, ascending = F, show_genes =  F, pValAsSize = F, graph_scale = 3, sqrtYscale = F, yUpperLim = NA)
graph_singlePopAlleleFreq(masterTable, SinglePopTable, graph_style = 'bar', facet_graph = T, orderless = T, ascending = F, show_genes =  F, pValAsSize = F, graph_scale = 3, sqrtYscale = F, yUpperLim = NA)
graph_singlePopAlleleFreq(masterTable, SinglePopTable, graph_style = 'bar', facet_graph = T, orderless = T, ascending = T, show_genes =  F, pValAsSize = F, graph_scale = 3, sqrtYscale = F, yUpperLim = NA)
graph_singlePopAlleleFreq(masterTable, SinglePopTable, graph_style = 'bar', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = F, graph_scale = 3, sqrtYscale = F, yUpperLim = NA)
graph_singlePopAlleleFreq(masterTable, SinglePopTable, graph_style = 'bar', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 3, sqrtYscale = F, yUpperLim = NA)
graph_singlePopAlleleFreq(masterTable, SinglePopTable, graph_style = 'bar', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 4, sqrtYscale = F, yUpperLim = NA)
graph_singlePopAlleleFreq(masterTable, SinglePopTable, graph_style = 'bar', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 4, sqrtYscale = T, yUpperLim = NA)
graph_singlePopAlleleFreq(masterTable, SinglePopTable, graph_style = 'bar', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 4, sqrtYscale = T, yUpperLim = .75)
graph_singlePopAlleleFreq(masterTable, SinglePopTable, numVariants = 15, graph_style = 'bar', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 1, sqrtYscale = T, yUpperLim = .75, export = T, file_name = "pointSinglePop_full_options_testExport") # error
graph_singlePopAlleleFreq(masterTable, SinglePopTable, graph_style = 'bar', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 1, sqrtYscale = T, yUpperLim = .75, export = T, file_name = "barSinglePop_full_options_testExport1")
graph_singlePopAlleleFreq(masterTable, SinglePopTable, numVariants = 15, graph_style = 'bar', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 1, sqrtYscale = T, yUpperLim = .75, export = T, file_name = "barSinglePop_full_options_testExport2") # error
dataStart <- IntAlldata
tableNum = 2
popTableNum = 2
dataIn <- dataStart[[2]][[tableNum]]
graph_singlePopAlleleFreq(masterTable, SinglePopTable, graph_style = 'point', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 3, sqrtYscale = F, yUpperLim = NA)
graph_singlePopAlleleFreq(masterTable, SinglePopTable, graph_style = 'point', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 4, sqrtYscale = F, yUpperLim = NA)
graph_singlePopAlleleFreq(masterTable, SinglePopTable, graph_style = 'point', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 4, sqrtYscale = T, yUpperLim = NA)
graph_singlePopAlleleFreq(masterTable, SinglePopTable, graph_style = 'point', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 4, sqrtYscale = T, yUpperLim = .75)
graph_singlePopAlleleFreq(masterTable, SinglePopTable, numVariants = 15, graph_style = 'point', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 4, sqrtYscale = T, yUpperLim = .75, export = T, file_name = "pointSinglePop_full_options_testExport")
graph_singlePopAlleleFreq(masterTable, SinglePopTable, numVariants = 15, graph_style = 'point', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 1, sqrtYscale = T, yUpperLim = NA, export = T, file_name = "pointSinglePop_full_options_testExport")
graph_singlePopAlleleFreq(masterTable, SinglePopTable, graph_style = 'point', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 1, sqrtYscale = T, yUpperLim = .75, export = T, file_name = "pointSinglePop_full_options_testExport1")
graph_singlePopAlleleFreq(masterTable, SinglePopTable, numVariants = 15, graph_style = 'point', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 1, sqrtYscale = T, yUpperLim = .75, export = T, file_name = "pointSinglePop_full_options_testExport2")
graph_singlePopAlleleFreq(masterTable, SinglePopTable, graph_style = 'bar', facet_graph = F, orderless = F, ascending = F, show_genes =  F, pValAsSize = F, graph_scale = 3, sqrtYscale = F, yUpperLim = NA) #default
graph_singlePopAlleleFreq(masterTable, SinglePopTable, graph_style = 'bar', facet_graph = T, orderless = F, ascending = F, show_genes =  F, pValAsSize = F, graph_scale = 3, sqrtYscale = F, yUpperLim = NA)
graph_singlePopAlleleFreq(masterTable, SinglePopTable, graph_style = 'bar', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 4, sqrtYscale = T, yUpperLim = NA)
graph_singlePopAlleleFreq(masterTable, SinglePopTable, graph_style = 'bar', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 4, sqrtYscale = T, yUpperLim = .75)
graph_singlePopAlleleFreq(masterTable, SinglePopTable, numVariants = 15, graph_style = 'bar', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 1, sqrtYscale = T, yUpperLim = .75, export = T, file_name = "pointSinglePop_full_options_testExport") # error
graph_singlePopAlleleFreq(masterTable, SinglePopTable, graph_style = 'bar', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 1, sqrtYscale = T, yUpperLim = .75, export = T, file_name = "barSinglePop_full_options_testExport1")
graph_singlePopAlleleFreq(masterTable, SinglePopTable, numVariants = 15, graph_style = 'bar', facet_graph = T, orderless = T, ascending = T, show_genes =  T, pValAsSize = T, graph_scale = 1, sqrtYscale = T, yUpperLim = .75, export = T, file_name = "barSinglePop_full_options_testExport2") # error
source("bootCall2.R")
source("../bootCall2.R")
getwd()
source("bootCalls2.R")
asso <- data.table::fread("D:\\Kulathinal_files\\GWASc_All_Data_20230114\\gwas_catalog_v1.0.2-associations_e108_r2023-01-14.tsv")
getwd()
setwd('./WorkingData')
getwd()
save(asso, "GwasAssocitions.rda")
save(asso, file ="GwasAssocitions.rda")
setwd("../")
getwd()
# Load data
load("./WorkingData/GwasAssocitions.rda")
rm(asso)
# Load data
load("./WorkingData/GwasAssocitions.rda")
allrsID <- asso$SNPS
head(allrsID)
allrsID <- unique(asso$SNPS)
head(allrsID)
allrsID <- asso$SNPS
allrsID <- unique(asso$SNPS) #
numChunks <- length(allrsID)/100
class(allrsID)
?split
allrsID <- split(allrsID, ceiling(seq_along(allrsID)/100))
#saving new data object
save(asso, allrsID, file ="GwasAssocitions.rda")
# Naming entries of 'allrsID'
nameVec <- rep("Chunk", 2498)
# Naming entries of 'allrsID'
nameVec <- rep("Chunk_", 2498)
for (i in 1:length(nameVec)){
nameVec[i] <- paste0(nameVec[i], i)
}
View(allrsID)
# Then apply those names
names(allrsID) <- nameVec
View(allrsID)
#saving new data object
save(asso, allrsID, file ="GwasAssocitions.rda")
# Function development ------------------------------------------------------
# create empty list,
# for i in 1:nChunks{ call data collecting func for chunk startingChunk+i; store data in empty list; if error arises, report which chunk it failed on by appending value to the list (so add "chunk_startingCHunk+i produced an error)} then continue.
#
?append
a <- list()
a['chun_1'] <- c(1,2,3)
a[['chun_1']] <- c(1,2,3)
a[["chun2"]] <- rep(20,34)
View(a)
sc = 5
fileName <- paste0("chunk", sc, "-", sc+sc, ".rds")
library(GWASpops.pheno2geno)
?createMT
#Setup Environment
source("bootCalls2.R")
load("./WorkingData/GwasAssocitions.rda")
library(GWASpops.pheno2geno)
chunk1 <- allrsID[[1]]
class(chunk1)
getPopsData <- function(rsIDChunkList, nChunks, startingChunk, reportNumErrors = TRUE){
# end chunk = nChunks+startingChunk and will be the next starting chunk and will not be called for in a given run. The final ending chunk must thus be 2499
retList <- list()
for (i in 1:nChunks){
chunk <- (startingChunk + i - 1)
chnkName <- paste0("Chunk_", chunk, "_CONT")
retList[[chnkName]] <- GWASpops.pheno2geno:::get_ensVariants(rsIDChunkList[[chunk]], population_data = TRUE)
}
fileName <- paste0("chunk", startingChunk, "-", (startingChunk+nChunks-1) , ".rds")
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData")
save(retList, file = fileName)
setwd("../")
if(reportNumErrors){
numErrors <- countErrors(retList)
cat(paste0("numErrors: ", numErrors))
}
return(retList)
}
# TEST CALL
testDataRetr <- getPopsData(allrsID, nChunks = 2, startingChunk = 1, reportNumErrors = F)
View(testDataRetr)
debug(getPopsData)
# TEST CALLS
testDataRetr <- getPopsData(allrsID, nChunks = 2, startingChunk = 1, reportNumErrors = F)
View(allrsID)
View(retList)
force(rsIDs)
View(response)
stop_for_status(response)
View(CONT)
View(retList)
testDataRetr_2 <- getPopsData(allrsID, nChunks = 3, startingChunk = 1, reportNumErrors = F)
undebug(getPopsData)
testDataRetr_2 <- getPopsData(allrsID, nChunks = 3, startingChunk = 1, reportNumErrors = F)
View(testDataRetr_2)
ch1Names <- names(allrsID[[1]])
ch1Names <- allrsID[[1]]
ch1Returned <- names(testDataRetr[[1]])
ch1Missing <- ch1Names[ch1Names %in% ch1Returned]
ch1Missing2 <- ch1Names[ch1Returned %in% ch1Names]
mask <- ch1Returned %in% ch1Names
mask <- ch1Names %in% ch1Returned # mask of size 99
mask <- ch1Returned %in% ch1Names # mask of size 99
mask2 <- ch1Names %in% ch1Returned # mask of size 99
sum(mask)
sum(mask2)
?setdiff
tSDiff <- setdiff(ch1Names, ch1Returned)
tsDiff
tSDiff
Ch1Names
ch1Names
ABsd <- tSDiff
BAsetDiff <- setdiff(ch1Returned, ch1Names)
BAsetDiff
View(asso)
allrsID_u <- unique(asso$SNPS)
allchr <- grep("^chr", allrsID_u)
13192/249792
allrsID_u <- allrsID_u[!allchr]
allrsID_u <- unique(asso$SNPS)
allrsID_u <- allrsID_u[allchr]
allrsID_u <- allrsID_u[!allchr]
allrsID_u <- unique(asso$SNPS)
sdTest <- setdiff(allrsID_u, allchr)
sdTest <- setdiff(1:length(allrsID_u), allchr)
249792 - 13192
?drop
allrsID_u <- allrsID_u[sdTest]
# Generate new Chunk list
allrsID <- split(allrsID_u, ceiling(seq_along(allrsID_u)/100))
View(allrsID)
nameVec <- rep("Chunk_", 2366)
for (i in 1:length(nameVec)){
nameVec[i] <- paste0(nameVec[i], i)
}
names(allrsID) <- nameVec
View(allrsID)
getwd()
setwd('./WorkingData')
save(asso, allrsID, file ="GwasAssocitions.rda")
setwd("../")
getwd()
allrsID[["Chunk_1"]]
allrsID[["Chunk_7"]]
allrsID[["Chunk_2"]]
allrsID[["Chunk_3"]]
allrsID[["Chunk_4"]]
allrsID[["Chunk_6"]]
# WITH NON rsID SNP entries removed from 'allrsID' RETEST BASIC FUNC CALL:
#     still need to determine why we aren't getting the same number of IDs back as we call for at times..
testDataRetr <- getPopsData(allrsID, nChunks = 2, startingChunk = 1, reportNumErrors = F)
View(testDataRetr)
testDataRetr <- getPopsData(allrsID, nChunks = 5, startingChunk = 1, reportNumErrors = F)
View(testDataRetr_2)
View(testDataRetr)
allrsID_u <- unique(asso$SNPS)
allrsID_u2 <- unique(asso$SNPS)
allchr <- grep("^chr", allrsID_u2)
sdMask <- setdiff(1:length(allrsID_u2), allchr)
allrsID_u2 <- allrsID_u2[sdMask]
allMultiEntries <- grep(";", allrsID_u2)
sdMask2 <- setdiff(1:length(allrsID_u2), allMultiEntries)
236600 - 1258
allrsID_u2 <- allrsID_u2[sdMask2]
allrsID <- split(allrsID_u2, ceiling(seq_along(allrsID_u2)/100))
nameVec <- rep("Chunk_", 2354)
for (i in 1:length(nameVec)){
nameVec[i] <- paste0(nameVec[i], i)
}
names(allrsID) <- nameVec
# saving updated objects again
save(asso, allrsID, file ="GwasAssocitions.rda")
getPopsData <- function(rsIDChunkList, nChunks, startingChunk, reportNumErrors = TRUE){
# end chunk = nChunks+startingChunk and will be the next starting chunk and will not be called for in a given run. The final ending chunk must thus be 2499
retList <- list()
for (i in 1:nChunks){
chunk <- (startingChunk + i - 1)
chnkName <- paste0("Chunk_", chunk, "_CONT")
retList[[chnkName]] <- GWASpops.pheno2geno:::get_ensVariants(rsIDChunkList[[chunk]], population_data = TRUE)
}
fileName <- paste0("chunk", startingChunk, "-", (startingChunk+nChunks-1) , ".rds")
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData")
save(retList, file = fileName)
setwd("../")
if(reportNumErrors){
numErrors <- countErrors(retList)
cat(paste0("numErrors: ", numErrors))
}
return(retList)
}
allrsID_u2 <- unique(asso$SNPS)
allchr <- grep("^chr", allrsID_u2)
sdMask <- setdiff(1:length(allrsID_u2), allchr)
allrsID_u2 <- allrsID_u2[sdMask]
allMultiEntries <- grep(";", allrsID_u2)
# saving incices of multiEntry rows
setwd("./workingData")
save(allMultiEntries, allrsID_u2, file ="multiEntrySNPs.rda")
sum(1:10)
#Setup Environment
source("bootCalls2.R")
load("./WorkingData/GwasAssocitions.rda")
library(GWASpops.pheno2geno)
getPopsData <- function(rsIDChunkList, nChunks, startingChunk, reportNumErrors = TRUE){
# end chunk = nChunks+startingChunk and will be the next starting chunk and will not be called for in a given run. The final ending chunk must thus be 2499
retList <- list()
for (i in 1:nChunks){
chunk <- (startingChunk + i - 1)
chnkName <- paste0("Chunk_", chunk, "_CONT")
retList[[chnkName]] <- GWASpops.pheno2geno:::get_ensVariants(rsIDChunkList[[chunk]], population_data = TRUE)
}
fileName <- paste0("chunk", startingChunk, "-", (startingChunk+nChunks-1) , ".rds")
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\unprocessedChunks")
save(retList, file = fileName)
setwd("../")
if(reportNumErrors){
numErrors <- countErrors(retList)
cat(paste0("numErrors: ", numErrors))
}
return(retList)
}
getPopsData <- function(rsIDChunkList, nChunks, startingChunk, reportNumErrors = TRUE){
# end chunk = nChunks+startingChunk and will be the next starting chunk and will not be called for in a given run. The final ending chunk must thus be 2499
retList <- list()
for (i in 1:nChunks){
chunk <- (startingChunk + i - 1)
chnkName <- paste0("Chunk_", chunk, "_CONT")
retList[[chnkName]] <- GWASpops.pheno2geno:::get_ensVariants(rsIDChunkList[[chunk]], population_data = TRUE)
}
fileName <- paste0("chunk", startingChunk, "-", (startingChunk+nChunks-1) , ".rds")
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\unprocessedChunks")
save(retList, file = fileName)
setwd("../")
if(reportNumErrors){
numErrors <- countErrors(retList)
cat(paste0("numErrors: ", numErrors))
}
return(retList)
}
allrsFlat <- flatten(allrsID)
allrsFlat <- as.character(flatten(allrsID))
goodEntries <- grep("^rs\d+[^\s]", allrsFlat)
goodEntries <- grep("^rs\\d+[^\\s]", allrsFlat)
goodEntries <- grep("^rs\\d+[^\\s]", allrsFlat) # of 235,342 entries 234,303 were hit...
badEntries <- setdiff(1:length(allrsFlat), goodEntries)
rsBad <- allrsFlat[badEntries]
rsBad
allrsID <- split(allrsFlat, ceiling(seq_along(allrsFlat)/100))
View(allrsID)
allrsFlat <- allrsFlat[goodEntries]
allrsID <- split(allrsFlat, ceiling(seq_along(allrsFlat)/100))
nameVec <- rep("Chunk_", 2344)
for (i in 1:length(nameVec)){
nameVec[i] <- paste0(nameVec[i], i)
}
names(allrsID) <- nameVec
View(allrsID)
setwd("./workingData")
save(asso, allrsID, file ="GwasAssocitions.rda")
setwd("../")
getwd()
# TESTING AFTER POSITIVE FILTERING OF allrsID object:
testDataRetr <- getPopsData(allrsID, nChunks = 5, startingChunk = 1, reportNumErrors = F)
View(testDataRetr)
allrsID[[1]]
allrsID[[2]]
allrsID[[5]]
ch1Names <- allrsID[[1]]
chunck_2sub <- allrsID[[2]]
chunk_2sub <- split(chunck_2sub, ceiling(seq_along(chunck_2sub)/10))
View(chunk_2sub)
chnk2Test <- getPopsData(chunk_2sub, nChunks = 10, startingChunk = 1, reportNumErrors = F)
chnk2Test[[1]][2]
getErr_ch2 <- chunk_2sub
chunk_2sub[[1]][2]
chunk_2sub[[1]][2] <- "WILL?this Get Error?"
chunk_2sub[[1]][2]
chunk_2sub <- split(chunck_2sub, ceiling(seq_along(chunck_2sub)/10))
getErr_ch2[[1]][2] <- "WILL?this Get Error?"
getErr_ch2[[1]][2]
getErr_ch2
View(chnk2Test)
# RESULT: sub-chunks 4 and 5 failed... others worked fine.. so maybe we can search ensembl for the ids within and see about missing values.. maybe values with no return crash calls?
chunk_2sub[[4]]
chunk_2_4sub <- split(chunk_2sub[[4]],ceiling(seq_along(chunk_2sub[[4]])/1 ))
View(chunk_2_4sub)
chnk2_sub4Test <- getPopsData(chunk_2_4sub, nChunks = 10, startingChunk = 1, reportNumErrors = F)
View(chnk2_sub4Test)
errorProductionTest <- getPopsData(getErr_ch2, nChunks = 2, startingChunk = 1, reportNumErrors = F)
View(errorProductionTest)
allrsID_ch10 <- split(allrsFlat, ceiling(seq_along(allrsFlat)/10))
nameVec <- rep("Chunk_", 23431)
for (i in 1:length(nameVec)){
nameVec[i] <- paste0(nameVec[i], i)
}
names(allrsID) <- nameVec
names(allrsID_ch10) <- nameVec
View(allrsID_ch10)
setwd("./workingData")
getwd()
save(asso, allrsID, allrsID_ch10, file ="GwasAssocitions.rda")
setwd("../")
setwd("./workingData")
save(asso, allrsID, allrsID_ch10, file ="rsIDlist_GWAS_asso.rda")
ch1Names <- allrsID[[1]]
getErr_ch2[[1]][2] <- "WILL?th\"is Get \Error\?"
getErr_ch2[[1]][2]
getErr_ch2[[1]][2] <- "WILL?th\\"is Get \Error\?"
getErr_ch2[[1]][2] <- "WILL?th\"is Get \\Error\\?"
getErr_ch2[[1]][2]
getErr_ch2[[1]][2] <- "WILL?.th\"i+_-s Get \\Error\\?"
getErr_ch2[[1]][2]
errorProductionTest <- getPopsData(getErr_ch2, nChunks = 2, startingChunk = 1, reportNumErrors = F) # try again
errorProductionTest <- getPopsData(getErr_ch2, nChunks = 2, startingChunk = 1, reportNumErrors = F) # try again after further string mangling.. this worked!!
source("D:/Programming/R_projects/Kulathinal_Lab/GWASpops.pheno2geno/workingScripts/PopulationsDataCollection.R", echo=TRUE)
size10_1000chunks <- getPopsData(allrsID_ch10, nChunks = 1000, startingChunk = 1, reportNumErrors = F)
load(.RData)
load(".RData")
getwd()
load("D:/Programming/R_projects/Kulathinal_Lab/GWASpops.pheno2geno/.RData")
a <- "this a dumb object"
getPopsData <- function(rsIDChunkList, nChunks, startingChunk, reportNumErrors = TRUE){
# end chunk = nChunks+startingChunk and will be the next starting chunk and will not be called for in a given run. The final ending chunk must thus be 2499
retList <- list()
for (i in 1:nChunks){
chunk <- (startingChunk + i - 1)
chnkName <- paste0("Chunk_", chunk, "_CONT")
retList[[chnkName]] <- tryCatch(
expr = {
GWASpops.pheno2geno:::get_ensVariants(rsIDChunkList[[chunk]], population_data = TRUE)
},
error = function(e){
warning(paste0("Error occured for ", chnkName))
return(chnkName) # this should just return a character vector instead of a list which will be our means of identifying error counts
}
)
}
fileName <- paste0("chunk", startingChunk, "-", (startingChunk+nChunks-1) , ".rds")
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\unprocessedChunks")
save(retList, file = fileName)
setwd("../")
if(reportNumErrors){
numErrors <- countErrors(retList)
cat(paste0("numErrors: ", numErrors))
}
return(retList)
}
#Setup Environment
source("bootCalls2.R")
load("./WorkingData/GwasAssocitions.rda")
library(GWASpops.pheno2geno)
View(getPopsData)
getErr_ch2 <- allrsID_ch10
getErr_ch2[[2]][2] <- "WILL?.th\"i+_-s Get \\Error\\?"
View(getErr_ch2)
getErr_ch2[["Chunk_2"]]
getErr_ch2[["Chunk_1"]]
errorProductionTest <- getPopsData(getErr_ch2, nChunks = 2, startingChunk = 1, reportNumErrors = F)# First error catch.. we should get a successful return with the appropriate default value back if error catching works
View(getErr_ch2)
View(errorProductionTest)
numErr <- length(errorProductionTest[is.character(errorProductionTest)])
is.character(errorProductionTest)
sapply(errorProductionTest, is.character)
numErr <- sum(sapply(errorProductionTest, is.character))
numErr <- sapply(errorProductionTest, is.character)
sum(numErr)
numErr <- sum(sapply(errorProductionTest, is.character))
getPopsData <- function(rsIDChunkList, nChunks, startingChunk, reportNumErrors = TRUE){
# end chunk = nChunks+startingChunk and will be the next starting chunk and will not be called for in a given run. The final ending chunk must thus be 2499
retList <- list()
for (i in 1:nChunks){
chunk <- (startingChunk + i - 1)
chnkName <- paste0("Chunk_", chunk, "_CONT")
retList[[chnkName]] <- tryCatch(
expr = {
GWASpops.pheno2geno:::get_ensVariants(rsIDChunkList[[chunk]], population_data = TRUE)
},
error = function(e){
warning(paste0("Error occured for ", chnkName))
return(chnkName) # this should just return a character vector instead of a list which will be our means of identifying error counts
}
)
}
fileName <- paste0("chunk", startingChunk, "-", (startingChunk+nChunks-1) , ".rds")
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\unprocessedChunks")
save(retList, file = fileName)
setwd("../")
if(reportNumErrors){
numErrors <- sum(sapply(retList, is.character))
cat(paste0("Number of empty chunks returned: ", numErrors))
cat("Empty chunks are returned as character vectors when an error is caught, or when the API fails to return expected data.")
}
return(retList)
}
View(getPopsData)
errorProductionTest_2 <- getPopsData(getErr_ch2, nChunks = 10, startingChunk = 1) # added in reporting on how many errors / empty returns occur per call for visibility of the process. Want to verify efficacy now.
View(errorProductionTest_2)
getPopsData <- function(rsIDChunkList, nChunks, startingChunk, reportNumErrors = TRUE){
# end chunk = nChunks+startingChunk and will be the next starting chunk and will not be called for in a given run. The final ending chunk must thus be 2499
retList <- list()
for (i in 1:nChunks){
chunk <- (startingChunk + i - 1)
chnkName <- paste0("Chunk_", chunk, "_CONT")
retList[[chnkName]] <- tryCatch(
expr = {
GWASpops.pheno2geno:::get_ensVariants(rsIDChunkList[[chunk]], population_data = TRUE)
},
error = function(e){
warning(paste0("Error occured for ", chnkName))
return(chnkName) # this should just return a character vector instead of a list which will be our means of identifying error counts
}
)
}
fileName <- paste0("chunk", startingChunk, "-", (startingChunk+nChunks-1) , ".rds")
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\unprocessedChunks")
save(retList, file = fileName)
setwd("../")
if(reportNumErrors){
numErrors <- sum(sapply(retList, is.character))
message(paste0("Number of empty chunks returned: ", numErrors))
message("\nEmpty chunks are returned as character vectors when an error is caught, or when the API fails to return expected data.\n")
}
return(retList)
}
errorProductionTest_2 <- getPopsData(getErr_ch2, nChunks = 3, startingChunk = 1) # added in reporting on how many errors / empty returns occur per call for visibility of the process. Want to verify efficacy now.
grabChunks <- function(data, StartChunk = 1, numCalls = 240){
#numCalls at default of 240 should mean that by default this would just call for all of the data
allrsID_ch10 <- data
for(i in 1:numCalls){
startPoint <- (StartChunk + (i - 1)*100) # incrementally updates starting chunk relative to starting point
if(startPoint > 23300){
message("All chunks should be grabbed except the last few")
return()
}
getPopsData(allrsID_ch10, 1, startPoint, reportNumErrors = FALSE)
}
message("call finished without automatic termination; i.e. not all chunks grabbed yet, but specified amount should be saved.")
return()
}
View(getPopsData)
View(grabChunks)
grabChunks <- function(data, StartChunk = 1,chunksPerCall = 100, numCalls = 240){
#numCalls at default of 240 should mean that by default this would just call for all of the data
allrsID_ch10 <- data
for(i in 1:numCalls){
startPoint <- (StartChunk + (i - 1)*chunksPerCall) # incrementally updates starting chunk relative to starting point
if(startPoint > 23300){
message("All chunks should be grabbed except the last few")
return()
}
getPopsData(allrsID_ch10, nChunks = chunksPerCall, startPoint, reportNumErrors = FALSE)
}
message("call finished without automatic termination; i.e. not all chunks grabbed yet, but specified amount should be saved.")
return()
}
View(grabChunks)
source("D:/Programming/R_projects/Kulathinal_Lab/GWASpops.pheno2geno/workingScripts/testDataSaving.R", echo=TRUE)
# CALL THESE MANUALLY, THEN CALL IN 'testDataSaving.R' ... watch for when new data is actually added to dedicated folder
dataSaving_1 <- getPopsData(allrsID_ch10, nChunks = 2, startingChunk = 1)
dataSaving_2 <- getPopsData(allrsID_ch10, nChunks = 2, startingChunk = 3)
dataSaving_3 <- getPopsData(allrsID_ch10, nChunks = 2, startingChunk = 5)
gChunksTest_1 <- grabChunks(allrsID_ch10, StartChunk = 1, chunksPerCall = 1, numCalls = 5) # we expect to see chunks 1-5 called for from this, all saved as their own rds files.. do we see them save as the function runs?
gChunksTest_1 <- grabChunks(allrsID_ch10, StartChunk = 1, chunksPerCall = 5, numCalls = 5) # we expect to see chunks 1-25 called for from this saved in 5 .rds files
grabChunks(allrsID_ch10, StartChunk = 1201) # this should just grab data until the cows come home. Will duplicate teh 1301-1400 chunk
grabChunks(allrsID_ch10, StartChunk = 2301) # windows decided it wanted to update without permission and killed my process.
20*235
4700/60
/24
78/24
grabChunks(allrsID_ch10, StartChunk = 3701)
grabChunks(allrsID_ch10, StartChunk = 12901)
grabChunks(allrsID_ch10, StartChunk = 16101)
