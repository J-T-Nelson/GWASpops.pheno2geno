return(masterTable)
}
)
# Transforming data for single population based data tables
singlePop_alleleFreqDTs <- lapply(Populations$Population_Abbreviation,
function(x) GWASpops.pheno2geno:::singlePopTransform(masterList[[2]], targetPopulation = x))
# Populations is a data object that comes with the package. (see ?Populations for more information or inspect the object itself.)
names(singlePop_alleleFreqDTs) <- Populations$Population_Abbreviation
masterListFinal <- list(masterTable, masterList[[2]], singlePop_alleleFreqDTs)
names(masterListFinal) <- c('masterTable', 'PopAlleleFreqData', 'singlePop_alleleFreqDTs')
return(masterListFinal) ######## END for pops
}
#------------- only variant data ------------------------
# Merging Ensembl variant and GWAS data tables
masterTable <- tryCatch(
expr = {
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name')
},
error = function(e){ # in the case of too many duplicate rows causing the merge to
# fail initially this option will allow for the merge to proceed.
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name', allow.cartesian = T);
message("merge.data.table performed with `allow.cartesian = TRUE`, therefore many extra rows may be produced. Duplicated rows have been removed");
masterTable$EnsVar_synonyms <- as.character(masterTable$EnsVar_synonyms);
masterTable <- masterTable[!duplicated(masterTable)]; #removing many duplicated rows created.
return(masterTable)
}
)
return(masterTable) ######### END for vars
}
tTransform <- ensListTransform_mod(dList, T)
debug(ensListTransform_mod)
tTransform <- ensListTransform_mod(dList, T)
names(GWAS_DF)
tTransform <- ensListTransform_mod(dList, T)
fAsso <- asso[asso$SNPS %in% names(testLNF)] # down to 3523 obs
undebug(ensListTransform_mod)
tTransform <- ensListTransform_mod(dList, T)
load_n_flatten <- function(numChunks, startChunk = 1) {
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\unprocessedChunks")
ret_list <- list()
for(i in 1:numChunks){
s <- startChunk + (i-1)*100
end <- s + 99
dataName <- paste0("chunk", s, "-", end, ".rds")
load(dataName)
ret_list[[dataName]] <- retList
}
ret_list <- purrr::flatten(ret_list)
ret_list <- purrr::flatten(ret_list)
return(ret_list)
}
testLNF <- load_n_flatten(numChunks = 3) # looks good. runs fast.
fAsso <- asso[asso$SNPS %in% names(testLNF)] # down to 3523 obs
# tranform
dList <- list(fAsso, testLNF)
#'
#'
#' @param dataList Data to be transformed. Must be in list format such that a GWAS data table is the first element and the respective data produced from calling Ensembl's REST API Variants endpoint with get_ensVariants() is the second element within the list. Position in the list is critical to successful execution of this function
#' @param popsData populations data transformation option. when TRUE function runs assuming variants from Ensembl REST API have been called with populations option activated, resulting output is different due to this extra population data.
#'
#' @return data.frame or list of data.frames
#'
#' @examples NA
#'
#' @export
ensListTransform_mod <- function(dataList, popsData = F) {
# dataList is a list with 2 elements, dataList[[1]] = GWAS data table ; dataList[[2]] = Ensembl API data in R list form
#CONT <- purrr::flatten(dataList[[2]]) #removing nested structure such that all sublists are combined into one list within dataList[[2]]
CONT <- purrr::compact(CONT) # removing empty elements introduced by:
## multiAPIcall_variants2 (?)... I think its one of the for loops that are fixing these data elements: EnsVar_synonyms and EnsVar_Clinical_significance.
GWAS_DF <- dataList[[1]] #storing GWAS data from GWAS files for later.. (similar to createMT())
data.table::setnames(GWAS_DF, old = 'SNPS', new = 'VariantID')
if(popsData){
# grabbing population data and converting into a list of tibbles.
popData <- sapply(CONT, function(x) x$populations) #OPTIMIZATION: this may be more efficient with masking.. not sure though
popData <- lapply(popData, function(x) dplyr::bind_rows(x)) # OPTIMIZATION: check if this can run without the anonymous function in lapply() .. I imagine its increasing operations for this call.
# removes populations from the response content so further operations proceed properly.
CONT <- lapply(CONT, function(x) x[names(x) != 'populations']) # OPTIMIZATION: Check for function which removes and returns elements from lists... as this call may removed if the original popData <- sapply() call removed and returned
}
# removing multimapping by flattening the lists out. (some rsIDs posses multiple mappings against the reference genome(?) or against different data within Ensembl's API databases(?) )
CONT <- GWASpops.pheno2geno:::fixMultiMapping(CONT)
CONT <- CONT[!sapply(CONT, is.null)] # this is a quick and dirty solution to the fact that fixMultiMapping() is producing null list entries at the end of its list output. I don't know why this is happening. OPTIMIZATION: DEBUG THE ISSUE MENTIONED IN THIS LINE FOR fixMultiMapping()  .... OPTIMIZATION 2: look to the comment below about $failed mappings being introduced occassionally, check for them within fixMultiMapping if possible and remove the need for additional code out here.
# infrequently a `$failed` key:value pair is being introduced into lists after flattening out mappings, this indicates that a mapping doesn't map to the reference genome in Ensembl's data base, thus we are removing such entries.
hasFailed <- sapply(CONT, \(x) rlang::has_name(x, "failed")) # MAKES Boolean mask
CONT <- CONT[!hasFailed] # USES Boolean mask to filter out entries with `failed` key:value pairs
CONT <- lapply(CONT, GWASpops.pheno2geno:::null2NA_ENSvariants)
CONT_Table <- GWASpops.pheno2geno:::rsTable(CONT) #CONT_Table at this point is just EnsVariants. No GWAS data or Pop data.
#renaming cols so their source is evident in the master table.
names(CONT_Table) <- paste0('EnsVar_',names(CONT_Table))
if(popsData){
# setting ancestral allele attribute on population frequency data.
popData <- GWASpops.pheno2geno:::AncestralAllele_attr(CONT_Table, popData)
masterList <- list(CONT_Table, popData)
# Merging Ensembl variant and GWAS data tables
masterTable <- tryCatch(
expr = {
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name')
},
error = function(e){ # in the case of too many duplicate rows causing the merge to
# fail initially this option will allow for the merge to proceed.
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name', allow.cartesian = T);
message("merge.data.table performed with `allow.cartesian = TRUE`, therefore many extra rows may be produced. Duplicated rows have been removed");
masterTable$EnsVar_synonyms <- as.character(masterTable$EnsVar_synonyms);
masterTable <- masterTable[!duplicated(masterTable)]; #removing many duplicated rows created.
return(masterTable)
}
)
# Transforming data for single population based data tables
singlePop_alleleFreqDTs <- lapply(Populations$Population_Abbreviation,
function(x) GWASpops.pheno2geno:::singlePopTransform(masterList[[2]], targetPopulation = x))
# Populations is a data object that comes with the package. (see ?Populations for more information or inspect the object itself.)
names(singlePop_alleleFreqDTs) <- Populations$Population_Abbreviation
masterListFinal <- list(masterTable, masterList[[2]], singlePop_alleleFreqDTs)
names(masterListFinal) <- c('masterTable', 'PopAlleleFreqData', 'singlePop_alleleFreqDTs')
return(masterListFinal) ######## END for pops
}
#------------- only variant data ------------------------
# Merging Ensembl variant and GWAS data tables
masterTable <- tryCatch(
expr = {
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name')
},
error = function(e){ # in the case of too many duplicate rows causing the merge to
# fail initially this option will allow for the merge to proceed.
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name', allow.cartesian = T);
message("merge.data.table performed with `allow.cartesian = TRUE`, therefore many extra rows may be produced. Duplicated rows have been removed");
masterTable$EnsVar_synonyms <- as.character(masterTable$EnsVar_synonyms);
masterTable <- masterTable[!duplicated(masterTable)]; #removing many duplicated rows created.
return(masterTable)
}
)
return(masterTable) ######### END for vars
}
tTransform <- ensListTransform_mod(dList, T)
#'
#'
#' @param dataList Data to be transformed. Must be in list format such that a GWAS data table is the first element and the respective data produced from calling Ensembl's REST API Variants endpoint with get_ensVariants() is the second element within the list. Position in the list is critical to successful execution of this function
#' @param popsData populations data transformation option. when TRUE function runs assuming variants from Ensembl REST API have been called with populations option activated, resulting output is different due to this extra population data.
#'
#' @return data.frame or list of data.frames
#'
#' @examples NA
#'
#' @export
ensListTransform_mod <- function(dataList, popsData = F) {
# dataList is a list with 2 elements, dataList[[1]] = GWAS data table ; dataList[[2]] = Ensembl API data in R list form
#CONT <- purrr::flatten(dataList[[2]]) #removing nested structure such that all sublists are combined into one list within dataList[[2]]
CONT <- dataList[[2]]
CONT <- purrr::compact(CONT) # removing empty elements introduced by:
## multiAPIcall_variants2 (?)... I think its one of the for loops that are fixing these data elements: EnsVar_synonyms and EnsVar_Clinical_significance.
GWAS_DF <- dataList[[1]] #storing GWAS data from GWAS files for later.. (similar to createMT())
data.table::setnames(GWAS_DF, old = 'SNPS', new = 'VariantID')
if(popsData){
# grabbing population data and converting into a list of tibbles.
popData <- sapply(CONT, function(x) x$populations) #OPTIMIZATION: this may be more efficient with masking.. not sure though
popData <- lapply(popData, function(x) dplyr::bind_rows(x)) # OPTIMIZATION: check if this can run without the anonymous function in lapply() .. I imagine its increasing operations for this call.
# removes populations from the response content so further operations proceed properly.
CONT <- lapply(CONT, function(x) x[names(x) != 'populations']) # OPTIMIZATION: Check for function which removes and returns elements from lists... as this call may removed if the original popData <- sapply() call removed and returned
}
# removing multimapping by flattening the lists out. (some rsIDs posses multiple mappings against the reference genome(?) or against different data within Ensembl's API databases(?) )
CONT <- GWASpops.pheno2geno:::fixMultiMapping(CONT)
CONT <- CONT[!sapply(CONT, is.null)] # this is a quick and dirty solution to the fact that fixMultiMapping() is producing null list entries at the end of its list output. I don't know why this is happening. OPTIMIZATION: DEBUG THE ISSUE MENTIONED IN THIS LINE FOR fixMultiMapping()  .... OPTIMIZATION 2: look to the comment below about $failed mappings being introduced occassionally, check for them within fixMultiMapping if possible and remove the need for additional code out here.
# infrequently a `$failed` key:value pair is being introduced into lists after flattening out mappings, this indicates that a mapping doesn't map to the reference genome in Ensembl's data base, thus we are removing such entries.
hasFailed <- sapply(CONT, \(x) rlang::has_name(x, "failed")) # MAKES Boolean mask
CONT <- CONT[!hasFailed] # USES Boolean mask to filter out entries with `failed` key:value pairs
CONT <- lapply(CONT, GWASpops.pheno2geno:::null2NA_ENSvariants)
CONT_Table <- GWASpops.pheno2geno:::rsTable(CONT) #CONT_Table at this point is just EnsVariants. No GWAS data or Pop data.
#renaming cols so their source is evident in the master table.
names(CONT_Table) <- paste0('EnsVar_',names(CONT_Table))
if(popsData){
# setting ancestral allele attribute on population frequency data.
popData <- GWASpops.pheno2geno:::AncestralAllele_attr(CONT_Table, popData)
masterList <- list(CONT_Table, popData)
# Merging Ensembl variant and GWAS data tables
masterTable <- tryCatch(
expr = {
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name')
},
error = function(e){ # in the case of too many duplicate rows causing the merge to
# fail initially this option will allow for the merge to proceed.
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name', allow.cartesian = T);
message("merge.data.table performed with `allow.cartesian = TRUE`, therefore many extra rows may be produced. Duplicated rows have been removed");
masterTable$EnsVar_synonyms <- as.character(masterTable$EnsVar_synonyms);
masterTable <- masterTable[!duplicated(masterTable)]; #removing many duplicated rows created.
return(masterTable)
}
)
# Transforming data for single population based data tables
singlePop_alleleFreqDTs <- lapply(Populations$Population_Abbreviation,
function(x) GWASpops.pheno2geno:::singlePopTransform(masterList[[2]], targetPopulation = x))
# Populations is a data object that comes with the package. (see ?Populations for more information or inspect the object itself.)
names(singlePop_alleleFreqDTs) <- Populations$Population_Abbreviation
masterListFinal <- list(masterTable, masterList[[2]], singlePop_alleleFreqDTs)
names(masterListFinal) <- c('masterTable', 'PopAlleleFreqData', 'singlePop_alleleFreqDTs')
return(masterListFinal) ######## END for pops
}
#------------- only variant data ------------------------
# Merging Ensembl variant and GWAS data tables
masterTable <- tryCatch(
expr = {
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name')
},
error = function(e){ # in the case of too many duplicate rows causing the merge to
# fail initially this option will allow for the merge to proceed.
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name', allow.cartesian = T);
message("merge.data.table performed with `allow.cartesian = TRUE`, therefore many extra rows may be produced. Duplicated rows have been removed");
masterTable$EnsVar_synonyms <- as.character(masterTable$EnsVar_synonyms);
masterTable <- masterTable[!duplicated(masterTable)]; #removing many duplicated rows created.
return(masterTable)
}
)
return(masterTable) ######### END for vars
}
tTransform <- ensListTransform_mod(dList, T)
#'
#'
#' @param dataList Data to be transformed. Must be in list format such that a GWAS data table is the first element and the respective data produced from calling Ensembl's REST API Variants endpoint with get_ensVariants() is the second element within the list. Position in the list is critical to successful execution of this function
#' @param popsData populations data transformation option. when TRUE function runs assuming variants from Ensembl REST API have been called with populations option activated, resulting output is different due to this extra population data.
#'
#' @return data.frame or list of data.frames
#'
#' @examples NA
#'
#' @export
ensListTransform_mod <- function(dataList, popsData = F) {
# dataList is a list with 2 elements, dataList[[1]] = GWAS data table ; dataList[[2]] = Ensembl API data in R list form
if(!requireNamespace("GWASpops.pheno2geno", quietly = TRUE)){
library(GWASpops.pheno2geno)
}
#CONT <- purrr::flatten(dataList[[2]]) #removing nested structure such that all sublists are combined into one list within dataList[[2]]
CONT <- dataList[[2]]
CONT <- purrr::compact(CONT) # removing empty elements introduced by:
## multiAPIcall_variants2 (?)... I think its one of the for loops that are fixing these data elements: EnsVar_synonyms and EnsVar_Clinical_significance.
GWAS_DF <- dataList[[1]] #storing GWAS data from GWAS files for later.. (similar to createMT())
data.table::setnames(GWAS_DF, old = 'SNPS', new = 'VariantID')
if(popsData){
# grabbing population data and converting into a list of tibbles.
popData <- sapply(CONT, function(x) x$populations) #OPTIMIZATION: this may be more efficient with masking.. not sure though
popData <- lapply(popData, function(x) dplyr::bind_rows(x)) # OPTIMIZATION: check if this can run without the anonymous function in lapply() .. I imagine its increasing operations for this call.
# removes populations from the response content so further operations proceed properly.
CONT <- lapply(CONT, function(x) x[names(x) != 'populations']) # OPTIMIZATION: Check for function which removes and returns elements from lists... as this call may removed if the original popData <- sapply() call removed and returned
}
# removing multimapping by flattening the lists out. (some rsIDs posses multiple mappings against the reference genome(?) or against different data within Ensembl's API databases(?) )
CONT <- GWASpops.pheno2geno:::fixMultiMapping(CONT)
CONT <- CONT[!sapply(CONT, is.null)] # this is a quick and dirty solution to the fact that fixMultiMapping() is producing null list entries at the end of its list output. I don't know why this is happening. OPTIMIZATION: DEBUG THE ISSUE MENTIONED IN THIS LINE FOR fixMultiMapping()  .... OPTIMIZATION 2: look to the comment below about $failed mappings being introduced occassionally, check for them within fixMultiMapping if possible and remove the need for additional code out here.
# infrequently a `$failed` key:value pair is being introduced into lists after flattening out mappings, this indicates that a mapping doesn't map to the reference genome in Ensembl's data base, thus we are removing such entries.
hasFailed <- sapply(CONT, \(x) rlang::has_name(x, "failed")) # MAKES Boolean mask
CONT <- CONT[!hasFailed] # USES Boolean mask to filter out entries with `failed` key:value pairs
CONT <- lapply(CONT, GWASpops.pheno2geno:::null2NA_ENSvariants)
CONT_Table <- GWASpops.pheno2geno:::rsTable(CONT) #CONT_Table at this point is just EnsVariants. No GWAS data or Pop data.
#renaming cols so their source is evident in the master table.
names(CONT_Table) <- paste0('EnsVar_',names(CONT_Table))
if(popsData){
# setting ancestral allele attribute on population frequency data.
popData <- GWASpops.pheno2geno:::AncestralAllele_attr(CONT_Table, popData)
masterList <- list(CONT_Table, popData)
# Merging Ensembl variant and GWAS data tables
masterTable <- tryCatch(
expr = {
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name')
},
error = function(e){ # in the case of too many duplicate rows causing the merge to
# fail initially this option will allow for the merge to proceed.
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name', allow.cartesian = T);
message("merge.data.table performed with `allow.cartesian = TRUE`, therefore many extra rows may be produced. Duplicated rows have been removed");
masterTable$EnsVar_synonyms <- as.character(masterTable$EnsVar_synonyms);
masterTable <- masterTable[!duplicated(masterTable)]; #removing many duplicated rows created.
return(masterTable)
}
)
# Transforming data for single population based data tables
singlePop_alleleFreqDTs <- lapply(Populations$Population_Abbreviation,
function(x) GWASpops.pheno2geno:::singlePopTransform(masterList[[2]], targetPopulation = x))
# Populations is a data object that comes with the package. (see ?Populations for more information or inspect the object itself.)
names(singlePop_alleleFreqDTs) <- Populations$Population_Abbreviation
masterListFinal <- list(masterTable, masterList[[2]], singlePop_alleleFreqDTs)
names(masterListFinal) <- c('masterTable', 'PopAlleleFreqData', 'singlePop_alleleFreqDTs')
return(masterListFinal) ######## END for pops
}
#------------- only variant data ------------------------
# Merging Ensembl variant and GWAS data tables
masterTable <- tryCatch(
expr = {
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name')
},
error = function(e){ # in the case of too many duplicate rows causing the merge to
# fail initially this option will allow for the merge to proceed.
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name', allow.cartesian = T);
message("merge.data.table performed with `allow.cartesian = TRUE`, therefore many extra rows may be produced. Duplicated rows have been removed");
masterTable$EnsVar_synonyms <- as.character(masterTable$EnsVar_synonyms);
masterTable <- masterTable[!duplicated(masterTable)]; #removing many duplicated rows created.
return(masterTable)
}
)
return(masterTable) ######### END for vars
}
tTransform <- ensListTransform_mod(dList, T)
fAsso <- asso[asso$SNPS %in% names(testLNF)] # down to 3523 obs
# tranform
dList <- list(fAsso, testLNF)
tTransform <- ensListTransform_mod(dList, T)
library(GWASpops.pheno2geno)
#'
#'
#' @param dataList Data to be transformed. Must be in list format such that a GWAS data table is the first element and the respective data produced from calling Ensembl's REST API Variants endpoint with get_ensVariants() is the second element within the list. Position in the list is critical to successful execution of this function
#' @param popsData populations data transformation option. when TRUE function runs assuming variants from Ensembl REST API have been called with populations option activated, resulting output is different due to this extra population data.
#'
#' @return data.frame or list of data.frames
#'
#' @examples NA
#'
#' @export
ensListTransform_mod <- function(dataList, popsData = F) {
# dataList is a list with 2 elements, dataList[[1]] = GWAS data table ; dataList[[2]] = Ensembl API data in R list form
if(!requireNamespace("GWASpops.pheno2geno", quietly = TRUE)){
library(GWASpops.pheno2geno)
}
Populations <- Populations
#CONT <- purrr::flatten(dataList[[2]]) #removing nested structure such that all sublists are combined into one list within dataList[[2]]
CONT <- dataList[[2]]
CONT <- purrr::compact(CONT) # removing empty elements introduced by:
## multiAPIcall_variants2 (?)... I think its one of the for loops that are fixing these data elements: EnsVar_synonyms and EnsVar_Clinical_significance.
GWAS_DF <- dataList[[1]] #storing GWAS data from GWAS files for later.. (similar to createMT())
data.table::setnames(GWAS_DF, old = 'SNPS', new = 'VariantID')
if(popsData){
# grabbing population data and converting into a list of tibbles.
popData <- sapply(CONT, function(x) x$populations) #OPTIMIZATION: this may be more efficient with masking.. not sure though
popData <- lapply(popData, function(x) dplyr::bind_rows(x)) # OPTIMIZATION: check if this can run without the anonymous function in lapply() .. I imagine its increasing operations for this call.
# removes populations from the response content so further operations proceed properly.
CONT <- lapply(CONT, function(x) x[names(x) != 'populations']) # OPTIMIZATION: Check for function which removes and returns elements from lists... as this call may removed if the original popData <- sapply() call removed and returned
}
# removing multimapping by flattening the lists out. (some rsIDs posses multiple mappings against the reference genome(?) or against different data within Ensembl's API databases(?) )
CONT <- GWASpops.pheno2geno:::fixMultiMapping(CONT)
CONT <- CONT[!sapply(CONT, is.null)] # this is a quick and dirty solution to the fact that fixMultiMapping() is producing null list entries at the end of its list output. I don't know why this is happening. OPTIMIZATION: DEBUG THE ISSUE MENTIONED IN THIS LINE FOR fixMultiMapping()  .... OPTIMIZATION 2: look to the comment below about $failed mappings being introduced occassionally, check for them within fixMultiMapping if possible and remove the need for additional code out here.
# infrequently a `$failed` key:value pair is being introduced into lists after flattening out mappings, this indicates that a mapping doesn't map to the reference genome in Ensembl's data base, thus we are removing such entries.
hasFailed <- sapply(CONT, \(x) rlang::has_name(x, "failed")) # MAKES Boolean mask
CONT <- CONT[!hasFailed] # USES Boolean mask to filter out entries with `failed` key:value pairs
CONT <- lapply(CONT, GWASpops.pheno2geno:::null2NA_ENSvariants)
CONT_Table <- GWASpops.pheno2geno:::rsTable(CONT) #CONT_Table at this point is just EnsVariants. No GWAS data or Pop data.
#renaming cols so their source is evident in the master table.
names(CONT_Table) <- paste0('EnsVar_',names(CONT_Table))
if(popsData){
# setting ancestral allele attribute on population frequency data.
popData <- GWASpops.pheno2geno:::AncestralAllele_attr(CONT_Table, popData)
masterList <- list(CONT_Table, popData)
# Merging Ensembl variant and GWAS data tables
masterTable <- tryCatch(
expr = {
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name')
},
error = function(e){ # in the case of too many duplicate rows causing the merge to
# fail initially this option will allow for the merge to proceed.
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name', allow.cartesian = T);
message("merge.data.table performed with `allow.cartesian = TRUE`, therefore many extra rows may be produced. Duplicated rows have been removed");
masterTable$EnsVar_synonyms <- as.character(masterTable$EnsVar_synonyms);
masterTable <- masterTable[!duplicated(masterTable)]; #removing many duplicated rows created.
return(masterTable)
}
)
# Transforming data for single population based data tables
singlePop_alleleFreqDTs <- lapply(Populations$Population_Abbreviation,
function(x) GWASpops.pheno2geno:::singlePopTransform(masterList[[2]], targetPopulation = x))
# Populations is a data object that comes with the package. (see ?Populations for more information or inspect the object itself.)
names(singlePop_alleleFreqDTs) <- Populations$Population_Abbreviation
masterListFinal <- list(masterTable, masterList[[2]], singlePop_alleleFreqDTs)
names(masterListFinal) <- c('masterTable', 'PopAlleleFreqData', 'singlePop_alleleFreqDTs')
return(masterListFinal) ######## END for pops
}
#------------- only variant data ------------------------
# Merging Ensembl variant and GWAS data tables
masterTable <- tryCatch(
expr = {
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name')
},
error = function(e){ # in the case of too many duplicate rows causing the merge to
# fail initially this option will allow for the merge to proceed.
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name', allow.cartesian = T);
message("merge.data.table performed with `allow.cartesian = TRUE`, therefore many extra rows may be produced. Duplicated rows have been removed");
masterTable$EnsVar_synonyms <- as.character(masterTable$EnsVar_synonyms);
masterTable <- masterTable[!duplicated(masterTable)]; #removing many duplicated rows created.
return(masterTable)
}
)
return(masterTable) ######### END for vars
}
fAsso <- asso[asso$SNPS %in% names(testLNF)] # down to 3523 obs
# tranform
dList <- list(fAsso, testLNF)
tTransform <- ensListTransform_mod(dList, T)
View(tTransform)
# After transform we calculate Fst per SNP, we bind all snps into one DF, transpose and append to the list before saving
setwd("..")
getwd()
# After transform we calculate Fst per SNP, we bind all snps into one DF, transpose and append to the list before saving
setwd("..")
getwd()
source("./R/fst_funcs.R")
fstTest <- hudsonFst_alleleList(tTransform[[2]], Populations, TRUE)
warnings()
thousGenPops <- populations[grep("1000GENOMES",populations$Population_Abbreviation)]
thousGenPops <- populations[grep("1000GENOMES",populations$Population_Abbreviation)]
thousGenPops <- Populations[grep("1000GENOMES", Populations$Population_Abbreviation)]
fstTest <- hudsonFst_alleleList(tTransform[[2]], thousGenPops, TRUE)
fstTest <- hudsonFst_alleleList(tTransform[[2]], thousGenPops, TRUE)
468/60
View(fstTest)
fstTest[["rs6921580"]]
fstObjOut <- fstTest[[1]]
View(9fstObjOut)
View(fstObjOut)
row.names(fstObjOut)
names(fstObjOut)
class(fstObjOut)
rm(tl, tl2, rs150537328, pops)
namedVec <- perAlleleFst_transform(dList[[2]]$rs6921580, thousGenPops, F)
# DETERMINE HOW TO GET NAMED VEC FROM perAlleleFst_transform()
d <- dList[[2]]$rs6921580
View(d)
View(dList)
namedVec <- perAlleleFst_transform(tTransform[[2]]$rs6921580, thousGenPops, F)
rm(d)
View(namedVec)
nVec <- namedVec[,6]
nVec <- as.named.vector(namedVec[,6])
class(namedVec)
nVec <- namedVec[,6, drop = FALSE]
View(nVec)
perAlleleFst_transform <- function(alleleDF, populations, deleteRedundants = FALSE){
# Extract data of interest from alleleDF
ancestralAllele <- attr(alleleDF, "Ancestral_Allele")
if(is.na(ancestralAllele)){ # sometimes ancestral Allele is NA, which makes the rest of this function impossible to execute. Calculating ancestral allele by finding allele with highest frequency.
ancestralAllele <- calc_ancestralAllele(alleleDF)
}
alleleDF <- alleleDF[alleleDF$population %in% populations$Population_Abbreviation & alleleDF$allele != ancestralAllele , ]
# Digest DF in to create DF out:
DF_rows <- nrow(alleleDF) # number for efficient pairwise iteration
if(DF_rows == 0){ # when no pops of interest exist for a given variant, we just cancel the function and return nothing
return(NULL)
}
rowHolder <- list()
for(i in 1:(DF_rows-1)){ # i correlates to a population
for(j in (1+i):DF_rows){ # j correlates to the second population used to pair with i's population
rName <- paste0(alleleDF$population[i], "-X-",alleleDF$population[j])
row <- c(rName,
populations[populations$Population_Abbreviation == alleleDF$population[i]]$Sample_Count,
alleleDF$frequency[i],
populations[populations$Population_Abbreviation == alleleDF$population[j]]$Sample_Count,
alleleDF$frequency[j])
rowHolder[[rName]] <- row
}
}
#setup return DF, name cols, fix col types, assign attributes
retDF <- as.data.frame(t(dplyr::bind_rows(rowHolder)))
names(retDF) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
retDF['n1'] <- as.numeric(retDF[['n1']])
retDF['n2'] <- as.numeric(retDF[['n2']])
retDF['p1'] <- as.numeric(retDF[['p1']])
retDF['p2'] <- as.numeric(retDF[['p2']])
attr(retDF, "Ancestral_Allele") <- ancestralAllele
attr(retDF, "VariantID") <- attr(alleleDF, "VariantID")
fstVec <- numeric(nrow(retDF))
for(i in 1:nrow(retDF)){
fstVec[i] <- HudsonFst(retDF[i,2],retDF[i,4],retDF[i,3],retDF[i,5])
}
retDF['Fst_Hudson'] <- fstVec
if(deleteRedundants){ #removing all but population pairs and Fst value to save memory, populations pairs are stored as row names
retDF <- retDF[,6, drop = FALSE] # drop = FALSE ensures we don't lose the row names in coercion
}
return(retDF)
}
t <- tTransform[[2]][1:10]
fstTest <- hudsonFst_alleleList(tTransform[[2]][1:100], thousGenPops, TRUE)
View(fstTest)
fstTest <- do.call(fstTest, rbind)
fstTest <- do.call(rbind, fstTest)
View(fstTest)
fstTest <- hudsonFst_alleleList(tTransform[[2]][1:100], thousGenPops, TRUE)
fstTest <- do.call(cbind, fstTest)
View(fstTest)
install.packages('rowr')
install.packages("rowr")
# chatGPT wrote this version:
fill_rows_gpt <- function(DF_list){
# find largest row
max_rows <- max(sapply(DF_list, nrow))
# get names of largest row as rowNames
rowNames <- names(which.max(sapply(DF_list, nrow)))
# for each DF in DF_list add missing rows with NA filled in using rowNames
for (i in seq_along(DF_list)) {
if (nrow(DF_list[[i]]) < max_rows) {
missing_rows <- data.frame(matrix(NA, nrow = max_rows - nrow(DF_list[[i]]), ncol = ncol(DF_list[[i]])))
row.names(missing_rows) <- setdiff(rowNames, row.names(DF_list[[i]]))
DF_list[[i]] <- rbind(DF_list[[i]], missing_rows)
}
}
return(DF_list)
}
View(fstTest)
filledTest <- fill_row_gpt(fstTest)
filledTest <- fill_rows_gpt(fstTest)
debug(fill_rows_gpt)
filledTest <- fill_rows_gpt(fstTest) # error
View(DF_list)
which.max(sapply(DF_list, nrow))
bigRows <- DF_list[[91]]
View(bigRows)
row.names(bigRows)
duplicated(row.names(bigRows))
sum(duplicated(row.names(bigRows)))
choose(32, 2)
sigmas <- seq(0.5,20,length.out = 20)
rm(sigmas)
