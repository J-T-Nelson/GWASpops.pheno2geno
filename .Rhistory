}
fileName <- paste0("chunk", startingChunk, "-", (startingChunk+nChunks-1) , ".rds")
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\unprocessedChunks")
save(retList, file = fileName)
setwd("../")
if(reportNumErrors){
numErrors <- sum(sapply(retList, is.character))
message(paste0("Number of empty chunks returned: ", numErrors))
message("\nEmpty chunks are returned as character vectors when an error is caught, or when the API fails to return expected data.\n")
}
return(retList)
}
errorProductionTest_2 <- getPopsData(getErr_ch2, nChunks = 3, startingChunk = 1) # added in reporting on how many errors / empty returns occur per call for visibility of the process. Want to verify efficacy now.
grabChunks <- function(data, StartChunk = 1, numCalls = 240){
#numCalls at default of 240 should mean that by default this would just call for all of the data
allrsID_ch10 <- data
for(i in 1:numCalls){
startPoint <- (StartChunk + (i - 1)*100) # incrementally updates starting chunk relative to starting point
if(startPoint > 23300){
message("All chunks should be grabbed except the last few")
return()
}
getPopsData(allrsID_ch10, 1, startPoint, reportNumErrors = FALSE)
}
message("call finished without automatic termination; i.e. not all chunks grabbed yet, but specified amount should be saved.")
return()
}
View(getPopsData)
View(grabChunks)
grabChunks <- function(data, StartChunk = 1,chunksPerCall = 100, numCalls = 240){
#numCalls at default of 240 should mean that by default this would just call for all of the data
allrsID_ch10 <- data
for(i in 1:numCalls){
startPoint <- (StartChunk + (i - 1)*chunksPerCall) # incrementally updates starting chunk relative to starting point
if(startPoint > 23300){
message("All chunks should be grabbed except the last few")
return()
}
getPopsData(allrsID_ch10, nChunks = chunksPerCall, startPoint, reportNumErrors = FALSE)
}
message("call finished without automatic termination; i.e. not all chunks grabbed yet, but specified amount should be saved.")
return()
}
View(grabChunks)
source("D:/Programming/R_projects/Kulathinal_Lab/GWASpops.pheno2geno/workingScripts/testDataSaving.R", echo=TRUE)
# CALL THESE MANUALLY, THEN CALL IN 'testDataSaving.R' ... watch for when new data is actually added to dedicated folder
dataSaving_1 <- getPopsData(allrsID_ch10, nChunks = 2, startingChunk = 1)
dataSaving_2 <- getPopsData(allrsID_ch10, nChunks = 2, startingChunk = 3)
dataSaving_3 <- getPopsData(allrsID_ch10, nChunks = 2, startingChunk = 5)
gChunksTest_1 <- grabChunks(allrsID_ch10, StartChunk = 1, chunksPerCall = 1, numCalls = 5) # we expect to see chunks 1-5 called for from this, all saved as their own rds files.. do we see them save as the function runs?
gChunksTest_1 <- grabChunks(allrsID_ch10, StartChunk = 1, chunksPerCall = 5, numCalls = 5) # we expect to see chunks 1-25 called for from this saved in 5 .rds files
grabChunks(allrsID_ch10, StartChunk = 1201) # this should just grab data until the cows come home. Will duplicate teh 1301-1400 chunk
grabChunks(allrsID_ch10, StartChunk = 2301) # windows decided it wanted to update without permission and killed my process.
20*235
4700/60
/24
78/24
grabChunks(allrsID_ch10, StartChunk = 3701)
grabChunks(allrsID_ch10, StartChunk = 12901)
grabChunks(allrsID_ch10, StartChunk = 16101)
5(1-6)
5*(1-6)
(5-2)**2
HudsonFst_slow <- function(n1, n2, p1, p2){
numerator <- ((p1-p2)**2 - (p1*(1-p1))/(n1-1) - (p2*(1-p2))/(n2-1))
denominator <- (p1*(1-p2) + p2*(1-p1))
return(numerator/denominator)
}
HudsonFst_slow <- function(n1, n2, p1, p2){
numerator <- ((p1-p2)**2 - (p1*(1-p1))/(n1-1) - (p2*(1-p2))/(n2-1))
denominator <- (p1*(1-p2) + p2*(1-p1))
return(numerator/denominator)
}
# no assignment should make for faster calculation on large data sets.
HudsonFst <- function(n1, n2, p1, p2){
return( ((p1-p2)**2 - (p1*(1-p1))/(n1-1) - (p2*(1-p2))/(n2-1)) / (p1*(1-p2) + p2*(1-p1)) )
}
library(GWASpops.pheno2geno)
tml <- testMasterList
View(tml)
perAllele_1 <- tml[[2]][[1]]
perAllele_1
attributes(perAllele_1)
View(perAllele_1)
populations <- Populations
View(populations)
africanSampleCount <- populations$Sample_Count[2]
african_SampleCount <- populations$Sample_Count[2]
american_SampleCount <- populations$Sample_Count[10]
perAllele_1$population['1000GENOMES:phase_3:AFR']
perAllele_1$population == '1000GENOMES:phase_3:AFR'
perAllele_1$population == '1000GENOMES:phase_3:AFR' && perAllele_1$allele != 'C'
perAllele_1$allele != 'C'
(perAllele_1$population == '1000GENOMES:phase_3:AFR' && perAllele_1$allele != 'C')
( (perAllele_1$population == '1000GENOMES:phase_3:AFR') && (perAllele_1$allele != 'C') )
( (perAllele_1$population == '1000GENOMES:phase_3:AFR') & (perAllele_1$allele != 'C') )
perAllele_1[(perAllele_1$population == '1000GENOMES:phase_3:AFR') & (perAllele_1$allele != 'C')]
perAllele_1[, (perAllele_1$population == '1000GENOMES:phase_3:AFR') & (perAllele_1$allele != 'C')]
perAllele_1[(perAllele_1$population == '1000GENOMES:phase_3:AFR') & (perAllele_1$allele != 'C'), ]
AFR_freq <- perAllele_1[(perAllele_1$population == '1000GENOMES:phase_3:AFR') & (perAllele_1$allele != 'C'), ]$frequency
AMR_freq <- perAllele_1[(perAllele_1$population == '1000GENOMES:phase_3:AMR') & (perAllele_1$allele != 'C'), ]$frequency
hSlow <- HudsonFst_slow(african_SampleCount,american_SampleCount, AFR_freq, AMR_freq)
american_SampleCount <- as.numeric(populations$Sample_Count[10])
african_SampleCount <- as.numeric(populations$Sample_Count[2])
hSlow <- HudsonFst_slow(african_SampleCount,american_SampleCount, AFR_freq, AMR_freq)
hSlow
hFast <- HudsonFst(african_SampleCount,american_SampleCount, AFR_freq, AMR_freq)
hFast
thousGenPops <- populations[grep("1000GENOMES",populations$Population_Abbreviation)]
View(thousGenPops)
# Num pairs = 32 Choose 2
numPairs <- choose(32,2)
numPairs
attributes(perAllele_1)
tDF <- data.frame()
attr(tDF) <- attributes(perAllele_1)
attributes(tDF) <- attributes(perAllele_1)
attr(tDF, "Ancestral_Allele") <- attr(perAllele_1, "Ancestral_Allele")
attributes(tDF)
perAllele_POI <- perAllele_1[perAllele_1$population %in% thousGenPops$Population_Abbreviation]
perAllele_1$population %in% thousGenPops$Population_Abbreviation
perAllele_POI <- perAllele_1[, perAllele_1$population %in% thousGenPops$Population_Abbreviation]
perAllele_POI <- perAllele_1[perAllele_1$population %in% thousGenPops$Population_Abbreviation , ]
AA <- attr(perAllele_1, 'Ancestral_Allele')
perAllele_POI <- perAllele_1[perAllele_1$population %in% thousGenPops$Population_Abbreviation & perAllele_1$allele != AA, ]
perAllele_POI_t <- perAllele_1[perAllele_1$population %in% thousGenPops$Population_Abbreviation, ]
View(perAllele_POI_t)
View(perAllele_POI)
length(perAllele_1)
length(perAllele_1[,])
length(perAllele_1[,1])
# perAllele... will take in a single allele DF and the populations desired to be digested, and will return a single DF
#   `populations` must be a character vector or something coercable into that form automatically.
perAlleleFst_transform <- function(alleleDF, populations){
#setup return DF, assign attributes
retDF <- data.frame()
ancestralAllele <- attr(alleleDF, "Ancestral_Allele")
attr(retDF, "Ancestral_Allele") <- ancestralAllele
attr(retDF, "VariantID") <- attr(alleleDF, "VariantID")
# Extract data of interest from alleleDF
alleleDF <- alleleDF[alleleDF$population %in% populations & alleleDF$allele != ancestralAllele]
# Digest DF in to create DF out
DF_rows <- nrow(alleleDF)
for(i in 1:DF_rows){ # i correlates to a population
for(j in (1+i):DF_rows){ # j correlates to the second population used to pair with i's population
}
}
}
n1ex <- thousGenPops[thousGenPops$Population_Abbreviation == perAllele_POI$population[1]]$Sample_Count
# making a dummy row
dummyRow <- c(paste0(perAllele_POI$population[1], "-X-",perAllele_POI$population[2]),
thousGenPops[thousGenPops$Population_Abbreviation == perAllele_POI$population[1]]$Sample_Count,
perAllele_POI$allele[1],
thousGenPops[thousGenPops$Population_Abbreviation == perAllele_POI$population[2]]$Sample_Count,
perAllele_POI$allele2)
# making a dummy row
dummyRow <- c(paste0(perAllele_POI$population[1], "-X-",perAllele_POI$population[2]),
thousGenPops[thousGenPops$Population_Abbreviation == perAllele_POI$population[1]]$Sample_Count,
perAllele_POI$allele[1],
thousGenPops[thousGenPops$Population_Abbreviation == perAllele_POI$population[2]]$Sample_Count,
perAllele_POI$allele[2])
dummyRow
# making a dummy row
dummyRow <- c(paste0(perAllele_POI$population[1], "-X-",perAllele_POI$population[2]),
thousGenPops[thousGenPops$Population_Abbreviation == perAllele_POI$population[1]]$Sample_Count,
perAllele_POI$frequency[1],
thousGenPops[thousGenPops$Population_Abbreviation == perAllele_POI$population[2]]$Sample_Count,
perAllele_POI$frequency[2])
dummyRow
append(rh, 'g')
rh <- list()
append(rh, 'g')
append(rh, 'good')
append(rh, 'good')
rh
View(rh)
rh <- c(rh, 'g')
rh <- c(rh, 'good')
rh <- c(rh, 'good')
rh
rhdf <- dplyr::bind_rows(rh)
rh # works well
rh <- list()
rh <- c(rh, 'g', 'gg', 5)
rh <- c(rh, 'good', 5 , 6)
rh <- c(rh, 'g', 'gg', 5)
rh <- c(rh, 'good', 5 , 6)
rh # works well
View(rh)
r1 <- c(rh, 'g', 'gg', 5)
r2 <- c(rh, 'good', 5 , 6)
rh <- list()
rh <- c(rh, r1)
rh <- c(rh, r2)
rh <- c(rh, r1)
rh <- c(rh, r2)
View(rh)
rh <- list()
View(r1)
r1 <- c(rh, 'g', 'gg', 5)
r2 <- c(rh, 'good', 5 , 6)
rh <- c(rh, r1)
rh <- c(rh, r2)
rh <- c(rh, r1)
rh <- c(rh, r2)
View(rh)
rh <- c(rh, dummyRow)
View(rh)
rh <- list()
rh <- list()
r1 <- list( 'g', 'gg', 5)
r2 <- list('good', 5 , 6)
rh <- list(rh, r1, r2)
View(rh)
rh <- list()
r1 <- list( 'g', 'gg', 5)
r2 <- list('good', 5 , 6)
rh <- list( r1, r2)
rh <- list(rh, r1, r2)
View(rh)
rh <- list()
r1 <- list( 'g', 'gg', 5)
r2 <- list('good', 5 , 6)
rh <- list( r1, r2)
?append
rh[["ham1"]] <- dummyRow
rh[["hammm"]] <- dummyRow
rh[["hammgf"]] <- r1
rh
View(rh)
rh <- list()
rh[["ham1"]] <- dummyRow
rh[["hammm"]] <- dummyRow
rh[["hammgf"]] <- r1
View(rh)
rh <- list()
rh[["ham1"]] <- dummyRow
rh[["hammm"]] <- dummyRow
# thinking that a named list is ideal... then each row will carry the name with it.. we still need to name cols though.
rhdf <- dplyr::bind_rows(rh)
View(rhdf)
# thinking that a named list is ideal... then each row will carry the name with it.. we still need to name cols though.
rhdf <- dplyr::bind_cols(rh)
# thinking that a named list is ideal... then each row will carry the name with it.. we still need to name cols though.
rhdf_row <- dplyr::bind_row(rh)
# thinking that a named list is ideal... then each row will carry the name with it.. we still need to name cols though.
rhdf_row <- dplyr::bind_rows(rh)
rhdf_col <- dplyr::bind_cols(rh)
t(rhdf)
# thinking that a named list is ideal... then each row will carry the name with it.. we still need to name cols though.
rhdf <- dplyr::bind_rows(rh)
rhdfFinal <- t(rhdf)
rhdfFinal <- as.data.frame(t(rhdf)) # its a fucking character vec
View(rhdfFinal)
?bind_rows
names(rhdfFinal) <- c("Pair", 'n1', "p1", 'n2', 'p2')
rhdfFinal
describe(rhdfFinal)
str(rhdfFinal)
rhdfFinal['pop_pair'] <- as.numeric(rhdfFinal['pop_pair'])
names(rhdfFinal) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
rhdfFinal['pop_pair'] <- as.numeric(rhdfFinal['pop_pair'])
View(rhdfFinal)
str(rhdfFinal) # bunch of character vecs
View(perAlleleFst_transform)
rhdfFinal['pop_pair'] <- as.numeric(rhdfFinal['pop_pair'])
rhdfFinal['pop_pair'] <- as.numeric(rhdfFinal[['pop_pair']])
View(rhdfFinal)
# thinking that a named list is ideal... then each row will carry the name with it.. we still need to name cols though.
rhdf <- dplyr::bind_rows(rh)
rhdfFinal <- as.data.frame(t(rhdf)) # its a fucking character vec
names(rhdfFinal) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
rhdfFinal
str(rhdfFinal) # bunch of character vecs
rhdfFinal['n1'] <- as.numeric(rhdfFinal[['n1']])
rhdfFinal
str(rhdfFinal)
rhdfFinal['n2'] <- as.numeric(rhdfFinal[['n2']])
rhdfFinal['p1'] <- as.numeric(rhdfFinal[['p1']])
rhdfFinal['p2'] <- as.numeric(rhdfFinal[['p2']])
str(rhdfFinal)
View(rhdfFinal)
perAlleleFst_transform <- function(alleleDF, populations){
# Extract data of interest from alleleDF
ancestralAllele <- attr(alleleDF, "Ancestral_Allele")
alleleDF <- alleleDF[alleleDF$population %in% populations & alleleDF$allele != ancestralAllele]
# Digest DF in to create DF out:
DF_rows <- nrow(alleleDF)
rowHolder <- list()
for(i in 1:DF_rows){ # i correlates to a population
for(j in (1+i):DF_rows){ # j correlates to the second population used to pair with i's population
rName <- paste0(alleleDF$population[i], "-X-",alleleDF$population[j])
row <- c(rName,
populations[populations$Population_Abbreviation == alleleDF$population[i]$Sample_Count],
alleleDF$frequency[i],
populations[populations$Population_Abbreviation == alleleDF$population[j]$Sample_Count],
alleleDF$frequency[j])
rowHolder[[rName]] <- row
}
}
#setup return DF, name cols, fix col types, assign attributes
retDF <- as.data.frame(t(dplyr::bind_rows(rowHolder)))
names(retDF) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
retDF['n1'] <- as.numeric(retDF[['n1']])
retDF['n2'] <- as.numeric(retDF[['n2']])
retDF['p1'] <- as.numeric(retDF[['p1']])
retDF['p2'] <- as.numeric(retDF[['p2']])
attr(retDF, "Ancestral_Allele") <- ancestralAllele
attr(retDF, "VariantID") <- attr(alleleDF, "VariantID")
return(retDF)
}
perAlleleFst_transform <- function(alleleDF, populations){
# Extract data of interest from alleleDF
ancestralAllele <- attr(alleleDF, "Ancestral_Allele")
alleleDF <- alleleDF[alleleDF$population %in% populations$Population_Abbreviation & alleleDF$allele != ancestralAllele]
# Digest DF in to create DF out:
DF_rows <- nrow(alleleDF)
rowHolder <- list()
for(i in 1:DF_rows){ # i correlates to a population
for(j in (1+i):DF_rows){ # j correlates to the second population used to pair with i's population
rName <- paste0(alleleDF$population[i], "-X-",alleleDF$population[j])
row <- c(rName,
populations[populations$Population_Abbreviation == alleleDF$population[i]$Sample_Count],
alleleDF$frequency[i],
populations[populations$Population_Abbreviation == alleleDF$population[j]$Sample_Count],
alleleDF$frequency[j])
rowHolder[[rName]] <- row
}
}
#setup return DF, name cols, fix col types, assign attributes
retDF <- as.data.frame(t(dplyr::bind_rows(rowHolder)))
names(retDF) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
retDF['n1'] <- as.numeric(retDF[['n1']])
retDF['n2'] <- as.numeric(retDF[['n2']])
retDF['p1'] <- as.numeric(retDF[['p1']])
retDF['p2'] <- as.numeric(retDF[['p2']])
attr(retDF, "Ancestral_Allele") <- ancestralAllele
attr(retDF, "VariantID") <- attr(alleleDF, "VariantID")
return(retDF)
}
perAlleleFst_transform <- function(alleleDF, populations){
# Extract data of interest from alleleDF
ancestralAllele <- attr(alleleDF, "Ancestral_Allele")
alleleDF <- alleleDF[alleleDF$population %in% populations$Population_Abbreviation & alleleDF$allele != ancestralAllele]
# Digest DF in to create DF out:
DF_rows <- nrow(alleleDF) # number for efficient pairwise iteration
rowHolder <- list()
for(i in 1:DF_rows){ # i correlates to a population
for(j in (1+i):DF_rows){ # j correlates to the second population used to pair with i's population
rName <- paste0(alleleDF$population[i], "-X-",alleleDF$population[j])
row <- c(rName,
populations[populations$Population_Abbreviation == alleleDF$population[i]$Sample_Count],
alleleDF$frequency[i],
populations[populations$Population_Abbreviation == alleleDF$population[j]$Sample_Count],
alleleDF$frequency[j])
rowHolder[[rName]] <- row
}
}
#setup return DF, name cols, fix col types, assign attributes
retDF <- as.data.frame(t(dplyr::bind_rows(rowHolder)))
names(retDF) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
retDF['n1'] <- as.numeric(retDF[['n1']])
retDF['n2'] <- as.numeric(retDF[['n2']])
retDF['p1'] <- as.numeric(retDF[['p1']])
retDF['p2'] <- as.numeric(retDF[['p2']])
attr(retDF, "Ancestral_Allele") <- ancestralAllele
attr(retDF, "VariantID") <- attr(alleleDF, "VariantID")
return(retDF)
}
hudmoPrep <- perAlleleFst_transform(perAllele_1, thousGenPops)
perAlleleFst_transform <- function(alleleDF, populations){
# Extract data of interest from alleleDF
ancestralAllele <- attr(alleleDF, "Ancestral_Allele")
alleleDF <- alleleDF[alleleDF$population %in% populations$Population_Abbreviation & alleleDF$allele != ancestralAllele , ]
# Digest DF in to create DF out:
DF_rows <- nrow(alleleDF) # number for efficient pairwise iteration
rowHolder <- list()
for(i in 1:DF_rows){ # i correlates to a population
for(j in (1+i):DF_rows){ # j correlates to the second population used to pair with i's population
rName <- paste0(alleleDF$population[i], "-X-",alleleDF$population[j])
row <- c(rName,
populations[populations$Population_Abbreviation == alleleDF$population[i]$Sample_Count],
alleleDF$frequency[i],
populations[populations$Population_Abbreviation == alleleDF$population[j]$Sample_Count],
alleleDF$frequency[j])
rowHolder[[rName]] <- row
}
}
#setup return DF, name cols, fix col types, assign attributes
retDF <- as.data.frame(t(dplyr::bind_rows(rowHolder)))
names(retDF) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
retDF['n1'] <- as.numeric(retDF[['n1']])
retDF['n2'] <- as.numeric(retDF[['n2']])
retDF['p1'] <- as.numeric(retDF[['p1']])
retDF['p2'] <- as.numeric(retDF[['p2']])
attr(retDF, "Ancestral_Allele") <- ancestralAllele
attr(retDF, "VariantID") <- attr(alleleDF, "VariantID")
return(retDF)
}
perAlleleFst_transform <- function(alleleDF, populations){
# Extract data of interest from alleleDF
ancestralAllele <- attr(alleleDF, "Ancestral_Allele")
alleleDF <- alleleDF[alleleDF$population %in% populations$Population_Abbreviation & alleleDF$allele != ancestralAllele , ]
# Digest DF in to create DF out:
DF_rows <- nrow(alleleDF) # number for efficient pairwise iteration
rowHolder <- list()
for(i in 1:DF_rows){ # i correlates to a population
for(j in (1+i):DF_rows){ # j correlates to the second population used to pair with i's population
rName <- paste0(alleleDF$population[i], "-X-",alleleDF$population[j])
row <- c(rName,
populations[populations$Population_Abbreviation == alleleDF$population[i]$Sample_Count],
alleleDF$frequency[i],
populations[populations$Population_Abbreviation == alleleDF$population[j]$Sample_Count],
alleleDF$frequency[j])
rowHolder[[rName]] <- row
}
}
#setup return DF, name cols, fix col types, assign attributes
retDF <- as.data.frame(t(dplyr::bind_rows(rowHolder)))
names(retDF) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
retDF['n1'] <- as.numeric(retDF[['n1']])
retDF['n2'] <- as.numeric(retDF[['n2']])
retDF['p1'] <- as.numeric(retDF[['p1']])
retDF['p2'] <- as.numeric(retDF[['p2']])
attr(retDF, "Ancestral_Allele") <- ancestralAllele
attr(retDF, "VariantID") <- attr(alleleDF, "VariantID")
return(retDF)
}
hudmoPrep <- perAlleleFst_transform(perAllele_1, thousGenPops)
hudmoPrep <- perAlleleFst_transform(perAllele_1, thousGenPops)
debug(perAlleleFst_transform)
hudmoPrep <- perAlleleFst_transform(perAllele_1, thousGenPops)
View(alleleDF)
hudmoPrep <- perAlleleFst_transform(perAllele_1, thousGenPops)
class(alleleDF)
class(populations)
hudmoPrep <- perAlleleFst_transform(perAllele_1, thousGenPops)
perAlleleFst_transform <- function(alleleDF, populations){
# Extract data of interest from alleleDF
ancestralAllele <- attr(alleleDF, "Ancestral_Allele")
alleleDF <- alleleDF[alleleDF$population %in% populations$Population_Abbreviation & alleleDF$allele != ancestralAllele , ]
# Digest DF in to create DF out:
DF_rows <- nrow(alleleDF) # number for efficient pairwise iteration
rowHolder <- list()
for(i in 1:DF_rows){ # i correlates to a population
for(j in (1+i):DF_rows){ # j correlates to the second population used to pair with i's population
rName <- paste0(alleleDF$population[i], "-X-",alleleDF$population[j])
row <- c(rName,
populations[populations$Population_Abbreviation == alleleDF$population[i]]$Sample_Count,
alleleDF$frequency[i],
populations[populations$Population_Abbreviation == alleleDF$population[j]]$Sample_Count,
alleleDF$frequency[j])
rowHolder[[rName]] <- row
}
}
#setup return DF, name cols, fix col types, assign attributes
retDF <- as.data.frame(t(dplyr::bind_rows(rowHolder)))
names(retDF) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
retDF['n1'] <- as.numeric(retDF[['n1']])
retDF['n2'] <- as.numeric(retDF[['n2']])
retDF['p1'] <- as.numeric(retDF[['p1']])
retDF['p2'] <- as.numeric(retDF[['p2']])
attr(retDF, "Ancestral_Allele") <- ancestralAllele
attr(retDF, "VariantID") <- attr(alleleDF, "VariantID")
return(retDF)
}
undebug(perAlleleFst_transform)
hudmoPrep <- perAlleleFst_transform(perAllele_1, thousGenPops)
debug(perAlleleFst_transform)
hudmoPrep <- perAlleleFst_transform(perAllele_1, thousGenPops)
View(rowHolder)
rowHolder[["1000GENOMES:phase_3:ACB-X-1000GENOMES:phase_3:AFR"]]
View(rowHolder)
choose(30,2)
sum(nrows(unique(rowHolder)))
uni <- unique(rowHolder)
df <- as.data.frame(rowHolder)
?as.data.frame
df <- dplyr::bind_rows(rowHolder)
?lengths
fiveLenList <- rowHolder[lengths(rowHolder) == 5]
perAlleleFst_transform <- function(alleleDF, populations){
# Extract data of interest from alleleDF
ancestralAllele <- attr(alleleDF, "Ancestral_Allele")
alleleDF <- alleleDF[alleleDF$population %in% populations$Population_Abbreviation & alleleDF$allele != ancestralAllele , ]
# Digest DF in to create DF out:
DF_rows <- nrow(alleleDF) # number for efficient pairwise iteration
rowHolder <- list()
for(i in 1:(DF_rows-1)){ # i correlates to a population
for(j in (1+i):DF_rows){ # j correlates to the second population used to pair with i's population
rName <- paste0(alleleDF$population[i], "-X-",alleleDF$population[j])
row <- c(rName,
populations[populations$Population_Abbreviation == alleleDF$population[i]]$Sample_Count,
alleleDF$frequency[i],
populations[populations$Population_Abbreviation == alleleDF$population[j]]$Sample_Count,
alleleDF$frequency[j])
rowHolder[[rName]] <- row
}
}
#setup return DF, name cols, fix col types, assign attributes
retDF <- as.data.frame(t(dplyr::bind_rows(rowHolder)))
names(retDF) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
retDF['n1'] <- as.numeric(retDF[['n1']])
retDF['n2'] <- as.numeric(retDF[['n2']])
retDF['p1'] <- as.numeric(retDF[['p1']])
retDF['p2'] <- as.numeric(retDF[['p2']])
attr(retDF, "Ancestral_Allele") <- ancestralAllele
attr(retDF, "VariantID") <- attr(alleleDF, "VariantID")
return(retDF)
}
hudmoPrep <- perAlleleFst_transform(perAllele_1, thousGenPops)
View(hudmoPrep)
