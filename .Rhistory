fstDF <- as.data.frame(t(fstDF)) # transpose s.t. rows are alleles, cols are population-pairs
masterList[['Fst_per_allele']] <- fstDF
# save new data structure in memory
if(saveData){
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\fst_GWAS_annotation_lists")
fileName <- paste0('fullData_', numChunks, '_', startChunk)
save(masterList, file = fileName)
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno")
}
# return nothing if desired, or resulting data structure if desired.
if(return_DS){
return(masterList)
} else{
return()
}
}
testMany_1 <- transform_fst_save(asso, 10, 1,thousGenPops, TRUE, TRUE) # this call had an issue where the calculation of Fst only seemed to happen for the first chunk loaded. Gotta see why.
testMany_1 <- transform_fst_save(asso, 10, 1,thousGenPops, TRUE, TRUE) # this call had an issue where the calculation of Fst only seemed to happen for the first chunk loaded. Gotta see why.
View(load_n_flatten)
debug(transform_fst_save)
testMany_1 <- transform_fst_save(asso, 10, 1,thousGenPops, TRUE, TRUE) # this call had an issue where the calculation of Fst only seemed to happen for the first chunk loaded. Gotta see why.
load_n_flatten <- function(numChunks, startSuperChunk = 1) {
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\unprocessedChunks")
ret_list <- list()
startPoint <- (startSuperChunk - 1)*100 + 1
for(i in 1:numChunks){
s <- startPoint + (i-1)*100
end <- s + 99
dataName <- paste0("chunk", s, "-", end, ".rds")
load(dataName)
ret_list[[dataName]] <- retList
}
ret_list <- purrr::flatten(ret_list)
ret_list <- purrr::flatten(ret_list)
return(ret_list)
}
# transform_fst_save() takes in the large GWAS association table, a number of chunks, and starting chunk and transforms the lists within the chunks into a list of DFs and lists OF DFs.. 4 objects specified above. Fst will be calculated within then the object will be saved.
transform_fst_save <- function(GWAS_associations,
numChunks,
startChunk = 1,
Fst_populations,
return_DS = FALSE,
saveData = TRUE){
# load data from memory and flatten for processing
variantList <- load_n_flatten(numChunks = numChunks, startSuperChunk = startChunk)
# compose list then tranform into GWASpops.geno2pheno masterList format
dataList <- list(GWAS_associations, variantList)
masterList <- ensListTransform_mod(dataList, TRUE)
# calculate Fst, delete redudant data vals, and discard multiallelic sites
fstList <- hudsonFst_alleleList(masterList[[2]], Fst_populations, deleteRedundants = TRUE, discardMultiAllelic =  TRUE)
# make single table of Fst Value list, then bind to masterList data structure
fstList <- fill_rows(fstList) # making all sublists compatible for binding together as data.frame
names <- names(fstList)
fstDF <- cbind.data.frame(fstList)
colnames(fstDF) <- names
fstDF <- as.data.frame(t(fstDF)) # transpose s.t. rows are alleles, cols are population-pairs
masterList[['Fst_per_allele']] <- fstDF
# save new data structure in memory
if(saveData){
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\fst_GWAS_annotation_lists")
fileName <- paste0('fullData_', numChunks, '_', startChunk)
save(masterList, file = fileName)
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno")
}
# return nothing if desired, or resulting data structure if desired.
if(return_DS){
return(masterList)
} else{
return()
}
}
testMany_1 <- transform_fst_save(asso, 10, 1,thousGenPops, TRUE, TRUE)
testMany_1 <- transform_fst_save(asso, 10, 2,thousGenPops, TRUE, TRUE)
View(testRun_3)
View(testMany_1)
# it runs.. still not getting the num of Fst calcs we should see....
rownames(testMany_1[[4]])
testMany_2 <- transform_fst_save(asso, 3, 20, thousGenPops, TRUE, TRUE)
warnings()
View(testMany_2)
fst_ret <- testMany_2[[4]]
View(fst_ret)
max_hudson <- max(as.matrix(fstPer))
max_hudson
max_hudson # NA ... ok that is just not helpful at all. why woudl this be a thing lol?
?max
max_hudson <- max(as.matrix(fstPer), na.rm = TRUE)
min_hudson <- min(as.matrix(fstPer), na.rm=T)
max_hudson # NA ... ok that is just not helpful at all. why woudl this be a thing lol?
min_hudson
testMany_3 <- transform_fst_save(asso, 5, 1, thousGenPops, TRUE, TRUE)
debug(transform_fst_save) # debugging to see what the heck is going on inside
testMany_3 <- transform_fst_save(asso, 5, 1, thousGenPops, TRUE, TRUE)
View(variantList)
View(masterList)
View(fstList)
View(variantList)
View(masterList)
popAlleleList <- masterList[[2]]
indexMulti <- sapply(popAlleleList, \(x) length(unique(x$allele)))
indexMultii <- which(indexMulti > 2 )
indexBi <- which(indexMulti < 3)
indexBi <- which(indexMulti = 2)
indexBi <- which(indexMulti == 2)
indexBi <- which(indexMulti < 3)
indexBi <- which(indexMulti == 0)
indexBi <- which(indexMulti == 1)
indexBi
indexBi <- which(indexMulti == 2)
paList <- popAlleleList[indexBi]
thousGenPops <- Populations[grep("1000GENOMES", Populations$Population_Abbreviation)]
View(paList)
paList[[1]]$population %in% thousGenPops
paList[["rs10430743"]][["population"]]
View(thousGenPops)
thousGenPops$Population_Abbreviation
thousGenPops %in% paList[[1]]$population
thousGenPops$Population_Abbreviation %in% paList[[1]]$population
hasPops <- sapply(paList, \(x) sum(thousGenPops$Population_Abbreviation %in% x$population))
hasPopsTot <- hasPops[hasPops > 0 ]
hasPops
unique(hasPopsTot)
fullFlatten <- load_n_flatten(100)
View(allrsID_ch10)
names <- names(fullFlatten)
rm(fullFlatten)
fullFlatten2 <- load_n_flatten(99, 101)
names2 <- names(fullFlatten2)
rm(fullFlatten2)
fullFlatten3 <- load_n_flatten(33, 201)
names3 <- names(fullFlatten3)
rm(fullFlatten3)
allNames <- append(names, names2, names3)
allNames <- append(names, c(names2, names3))
uniqueNames <- unique(allNames)
207839/220866
dupeIndex <- which(duplicated(allNames))
?range
range(dupeIndex)
# Create a vector of indices
indices <- c(10, 5000, 100000, 200000, 219999)
# Create a vector of values
values <- runif(220000, min = 0, max = 1)
# Plot the values at the specified indices
plot(indices, values[indices], pch = 19, col = "blue", xlab = "Index", ylab = "Value")
plot(dupeIndex)
hist(dupeIndex)
# Create a vector of indices
indices <- 1:220000
# Create a binary vector indicating presence or absence of values
presence <- ifelse(indices %in% dupeIndex, 1, 0)
# Plot the presence of values at each index
plot(indices, presence, pch = 19, col = "blue", xlab = "Index", ylab = "Presence")
dupeList <- split(dupeIndex,ceiling( seq_along(dupeIndex)/1000 ))
View(dupeList)
dupeList[["1"]]
dupeList[["2"]]
dupeList[["14"]]
dupeList[["13"]]
dupeList[["14"]]
dupeList2 <- split(dupeIndex, 14)
View(dupeList2)
ceiling( seq_along(dupeIndex)/1000 )
seq_along(dupeIndex)/1000
seq_along(dupeIndex)
?ifelse
dupeList[["13"]]
dupeList[["14"]]
getPopsData <- function(rsIDChunkList, nChunks, startingChunk, reportNumErrors = TRUE){
retList <- list()
for (i in 1:nChunks){
chunk <- (startingChunk + i - 1)
chnkName <- paste0("Chunk_", chunk, "_CONT")
retList[[chnkName]] <- tryCatch(
expr = {
GWASpops.pheno2geno:::get_ensVariants(rsIDChunkList[[chunk]], population_data = TRUE)
},
error = function(e){
warning(paste0("Error occured for ", chnkName))
return(chnkName) # this should just return a character vector instead of a list which will be our means of identifying error counts
}
)
}
fileName <- paste0("chunk", startingChunk, "-", (startingChunk+nChunks-1) , ".rds")
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\unprocessedChunks")
save(retList, file = fileName)
setwd("../")
if(reportNumErrors){
numErrors <- sum(sapply(retList, is.character))
message(paste0("Number of empty chunks returned: ", numErrors))
message("\nEmpty chunks are returned as character vectors when an error is caught, or when the API fails to return expected data.\n")
}
return(retList)
}
grabChunks <- function(data, StartChunk = 1,chunksPerCall = 100, numCalls = 240){
#numCalls at default of 240 should mean that by default this would just call for all of the data
allrsID_ch10 <- data
for(i in 1:numCalls){
startPoint <- (StartChunk + (i - 1)*chunksPerCall) # incrementally updates starting chunk relative to starting point
if(startPoint > 23300){
message("All chunks should be grabbed except the last few")
return()
}
getPopsData(allrsID_ch10, nChunks = chunksPerCall, startPoint, reportNumErrors = FALSE)
}
message("call finished without automatic termination; i.e. not all chunks grabbed yet, but specified amount should be saved.")
return()
}
View(grabChunks)
grabChunks(allrsID_ch10, StartChunk = 2, numCalls = 15) # re-grabbing duplicated data
grabChunks(allrsID_ch10, StartChunk = 401, numCalls = 13) # calls froze...
getPopsData <- function(rsIDChunkList, nChunks, startingChunk, reportNumErrors = TRUE){
retList <- list()
for (i in 1:nChunks){
chunk <- (startingChunk + i - 1)
chnkName <- paste0("Chunk_", chunk, "_CONT")
retList[[chnkName]] <- tryCatch(
expr = {
GWASpops.pheno2geno:::get_ensVariants(rsIDChunkList[[chunk]], population_data = TRUE)
},
error = function(e){
warning(paste0("Error occured for ", chnkName))
return(chnkName) # this should just return a character vector instead of a list which will be our means of identifying error counts
}
)
}
fileName <- paste0("chunk", startingChunk, "-", (startingChunk+nChunks-1) , ".rds")
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\unprocessedChunks")
save(retList, file = fileName)
setwd("../")
if(reportNumErrors){
numErrors <- sum(sapply(retList, is.character))
message(paste0("Number of empty chunks returned: ", numErrors))
message("\nEmpty chunks are returned as character vectors when an error is caught, or when the API fails to return expected data.\n")
}
return(retList)
}
grabChunks <- function(data, StartChunk = 1,chunksPerCall = 100, numCalls = 240){
#numCalls at default of 240 should mean that by default this would just call for all of the data
allrsID_ch10 <- data
for(i in 1:numCalls){
startPoint <- (StartChunk + (i - 1)*chunksPerCall) # incrementally updates starting chunk relative to starting point
if(startPoint > 23300){
message("All chunks should be grabbed except the last few")
return()
}
getPopsData(allrsID_ch10, nChunks = chunksPerCall, startPoint, reportNumErrors = FALSE)
}
message("call finished without automatic termination; i.e. not all chunks grabbed yet, but specified amount should be saved.")
return()
}
grabChunks(allrsID_ch10, StartChunk = 401, numCalls = 13) # calls froze...
fullFlatten <- load_n_flatten(15)
View(fullFlatten)
namesFF <- names(fullFlatten)
uNamesFF <- unique(namesFF)
dupeIndex2 <- which(duplicated(uNamesFF))
dupeIndex2 <- which(duplicated(NamesFF))
dupeIndex2 <- which(duplicated(namesFF))
dupeIndex2
fullFlatten_22 <- load_n_flatten(20)
namesFF22 <- names(fullFlatten) # 14572
uNamesFF22 <- unique(namesFF) # 13590 .... more duplication than I want.. something like 1 whole chunk... but not bad.
dupeIndex22 <- which(duplicated(namesFF))
dupeIndex22
grabChunks(allrsID_ch10, StartChunk = 1701, numCalls = 4) # will take like 2 hrs I think..
fullFlatten_22 <- load_n_flatten(20)
namesFF22 <- names(fullFlatten)
namesFF22 <- names(fullFlatten_22)
uNamesFF22 <- unique(namesFF22)
dupeIndex22 <- which(duplicated(namesFF22))
dupeIndex22
testMany_5 <- transform_fst_save(asso, 5, 2, thousGenPops, TRUE, TRUE)
library(GWASpops.pheno2geno)
testMany_5 <- transform_fst_save(asso, 5, 2, thousGenPops, TRUE, TRUE) # going to test this call to see if # fst out is closer to what is expected. ... we don't want to see 733 again.
13/417
View(testMany_5)
# transform_fst_save() takes in the large GWAS association table, a number of chunks, and starting chunk and transforms the lists within the chunks into a list of DFs and lists OF DFs.. 4 objects specified above. Fst will be calculated within then the object will be saved.
transform_fst_save <- function(GWAS_associations,
numChunks,
startChunk = 1,
Fst_populations,
return_DS = FALSE,
saveData = TRUE){
# load data from memory and flatten for processing
variantList <- load_n_flatten(numChunks = numChunks, startSuperChunk = startChunk)
# compose list then tranform into GWASpops.geno2pheno masterList format
dataList <- list(GWAS_associations, variantList)
masterList <- ensListTransform_mod(dataList, TRUE)
# calculate Fst, delete redudant data vals, and discard multiallelic sites
fstList <- hudsonFst_alleleList(masterList[[2]], Fst_populations, deleteRedundants = TRUE, discardMultiAllelic =  TRUE)
# make single table of Fst Value list, then bind to masterList data structure
fstList <- fill_rows(fstList) # making all sublists compatible for binding together as data.frame
names <- names(fstList)
fstDF <- cbind.data.frame(fstList)
colnames(fstDF) <- names
fstDF <- as.data.frame(t(fstDF)) # transpose s.t. rows are alleles, cols are population-pairs
masterList[['Fst_per_allele']] <- fstDF
# save new data structure in memory
if(saveData){
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\fst_GWAS_annotation_lists")
fileName <- paste0('fullData_', startChunk, '_', startChunk+numChunks)
save(masterList, file = fileName)
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno")
}
# return nothing if desired, or resulting data structure if desired.
if(return_DS){
return(masterList)
} else{
return()
}
}
# Cleaning environment:
rm(testMany_1, testMany_2,testMany_5, testRun_1, testRun_2, testRun_3, testRun_4)
rm(fst_ret, fstPer, fullFlatten, fullFlatten_22)
rm(a, pops, dupeIndex2, dupeIndex22, max_hudson, min_hudson, namesFF, namesFF22, uNamesFF, uNamesFF22)
testMany <- transform_fst_save(asso, 20, 1, thousGenPops, return_DS = TRUE, saveData = TRUE)
library(GWASpops.pheno2geno)
testMany <- transform_fst_save(asso, 20, 1, thousGenPops, return_DS = TRUE, saveData = TRUE)
warnings()
View(testMany)
# transform_fst_save() takes in the large GWAS association table, a number of chunks, and starting chunk and transforms the lists within the chunks into a list of DFs and lists OF DFs.. 4 objects specified above. Fst will be calculated within then the object will be saved.
transform_fst_save <- function(GWAS_associations,
numChunks,
startChunk = 1,
Fst_populations,
return_DS = FALSE,
saveData = TRUE){
# load data from memory and flatten for processing
variantList <- load_n_flatten(numChunks = numChunks, startSuperChunk = startChunk)
# compose list then tranform into GWASpops.geno2pheno masterList format
dataList <- list(GWAS_associations, variantList)
masterList <- ensListTransform_mod(dataList, TRUE)
# calculate Fst, delete redudant data vals, and discard multiallelic sites
fstList <- hudsonFst_alleleList(masterList[[2]], Fst_populations, deleteRedundants = TRUE, discardMultiAllelic =  TRUE)
# make single table of Fst Value list, then bind to masterList data structure
fstList <- fill_rows(fstList) # making all sublists compatible for binding together as data.frame
names <- names(fstList)
fstDF <- cbind.data.frame(fstList)
colnames(fstDF) <- names
fstDF <- as.data.frame(t(fstDF)) # transpose s.t. rows are alleles, cols are population-pairs
masterList[['Fst_per_allele']] <- fstDF
# save new data structure in memory
if(saveData){
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\fst_GWAS_annotation_lists")
fileName <- paste0('fullData_', startChunk, '_', startChunk+numChunks-1)
save(masterList, file = fileName)
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno")
}
# return nothing if desired, or resulting data structure if desired.
if(return_DS){
return(masterList)
} else{
return()
}
}
rm(testMany)
transform_fst_save(asso, numChunks = 10, startChunk = 21, thousGenPops, return_DS = FALSE, saveData = TRUE)
transform_fst_save(asso, numChunks = 10, startChunk = 31, thousGenPops, return_DS = FALSE, saveData = TRUE)
transform_fst_save(asso, numChunks = 10, startChunk = 41, thousGenPops, return_DS = FALSE, saveData = TRUE)
transform_fst_save(asso, numChunks = 10, startChunk = 51, thousGenPops, return_DS = FALSE, saveData = TRUE)
transform_fst_save(asso, numChunks = 10, startChunk = 71, thousGenPops, return_DS = FALSE, saveData = TRUE)
transform_fst_save(asso, numChunks = 10, startChunk = 81, thousGenPops, return_DS = FALSE, saveData = TRUE)
transform_fst_save(asso, numChunks = 10, startChunk = 91, thousGenPops, return_DS = FALSE, saveData = TRUE)
transform_fst_save(asso, numChunks = 10, startChunk = 101, thousGenPops, return_DS = FALSE, saveData = TRUE)
transform_fst_save(asso, numChunks = 10, startChunk = 111, thousGenPops, return_DS = FALSE, saveData = TRUE)
transform_fst_save(asso, numChunks = 10, startChunk = 121, thousGenPops, return_DS = FALSE, saveData = TRUE)
transform_fst_save(asso, numChunks = 10, startChunk = 131, thousGenPops, return_DS = FALSE, saveData = TRUE)
transform_fst_save(asso, numChunks = 10, startChunk = 141, thousGenPops, return_DS = FALSE, saveData = TRUE)
transform_fst_save(asso, numChunks = 10, startChunk = 151, thousGenPops, return_DS = FALSE, saveData = TRUE)
transform_fst_save(asso, numChunks = 10, startChunk = 161, thousGenPops, return_DS = FALSE, saveData = TRUE)
transform_fst_save(asso, numChunks = 10, startChunk = 171, thousGenPops, return_DS = FALSE, saveData = TRUE)
transform_fst_save(asso, numChunks = 10, startChunk = 181, thousGenPops, return_DS = FALSE, saveData = TRUE)
transform_fst_save(asso, numChunks = 10, startChunk = 191, thousGenPops, return_DS = FALSE, saveData = TRUE)
transform_fst_save(asso, numChunks = 10, startChunk = 201, thousGenPops, return_DS = FALSE, saveData = TRUE)
transform_fst_save(asso, numChunks = 10, startChunk = 211, thousGenPops, return_DS = FALSE, saveData = TRUE)
transform_fst_save(asso, numChunks = 10, startChunk = 221, thousGenPops, return_DS = FALSE, saveData = TRUE)
transform_fst_save(asso, numChunks = 3, startChunk = 231, thousGenPops, return_DS = FALSE, saveData = TRUE)
3000000000/2000000
2000000/3000000000
4000000/3000000000
View(HudsonFst)
pop1 <- .56
pop2 <- .84
pop3 <- .25
pop4 <- .01
n1 <- 534
n2 <- 233
n3 <- 28
n4 <- 4000
testPops <- c(pop1, pop2, pop3, pop4)
testSampleSizes <- c(n1, n2,n3,n4)
popPairs <- combn(testPops, 2)
popPairs
ssPairs <- combn(testSampleSizes,2)
ssPairs
choose(4,2)
class(popPairs)
popPairs_rev <- popPairs[c(2,1), ]
popPairs_rev
ssPairs_rev <- ssPairs[c(2,1), ]
for(i in 1:ncol(popPairs)){
HudsonFst(ssPairs[1, i], ssPairs[2, i], popPairs[1, i], popPairs[1, i],)
}
for(i in 1:ncol(popPairs)){
HudsonFst(ssPairs[1, i], ssPairs[2, i], popPairs[1, i], popPairs[1, i])
}
g
capture <- for(i in 1:ncol(popPairs)){
HudsonFst(ssPairs[1, i], ssPairs[2, i], popPairs[1, i], popPairs[1, i])
}
ssPairs[1, 1]
results <- lapply(1:ncol(popPairs), function(i) {
HudsonFst(ssPairs[1, i], ssPairs[2, i], popPairs[1, i], popPairs[1, i])
})
View(results)
comparisonNames <- c('pop1_pop2', 'pop1_pop3', 'pop1_pop4', 'pop2_pop3', 'pop2_pop4', 'pop3_pop4')
comparisonNames_rev <- c('pop2_pop1', 'pop3_pop1', 'pop4_pop1', 'pop3_pop2', 'pop4_pop2', 'pop4_pop3')
results_rev <- lapply(1:ncol(popPairs), function(i) {
HudsonFst(ssPairs_rev[1, i], ssPairs_rev[2, i], popPairs_rev[1, i], popPairs_rev[1, i])
})
names(results) <- comparisonNames
names(results_rev) <- comparisonNames_rev
View(results)
View(results_rev)
results
results_rev
pz <- Populations
View(pz)
View(HudsonFst)
HudsonFst(n2,n4, p2, p4)
HudsonFst(n2,n4, pop2, pop4)
captureList <- list()
for(pair in comparisonNames){
captureList[[pair]] <- HudsonFst(ssPairs[1, i], ssPairs[2, i], popPairs[1, i], popPairs[1, i])
}
View(captureList)
for(i in 1:length(comparisonNames)){
captureList[[ comparisonNames[i] ]] <- HudsonFst(ssPairs[1, i], ssPairs[2, i], popPairs[1, i], popPairs[1, i])
}
View(captureList)
HudsonFst(ssPairs[1, 5], ssPairs[2, 5], popPairs[1, 5], popPairs[1, 5])
ssPairs[1, 5]
HudsonFst(n2,n4, pop2, pop4)
n2
ssPairs[2, 5]
n4
popPairs[1, 5]
p2
pop2
popPairs[1, 5]
pop4
for(i in 1:length(comparisonNames)){
captureList[[ comparisonNames[i] ]] <- HudsonFst(ssPairs[1, i], ssPairs[2, i], popPairs[1, i], popPairs[2, i])
}
View(captureList)
# didn't know I could use lapply this way... thanks chatGPT
results <- lapply(1:ncol(popPairs), function(i) {
HudsonFst(ssPairs[1, i], ssPairs[2, i], popPairs[1, i], popPairs[2, i])
})
results_rev <- lapply(1:ncol(popPairs), function(i) {
HudsonFst(ssPairs_rev[1, i], ssPairs_rev[2, i], popPairs_rev[1, i], popPairs_rev[2, i])
})
results
names(results) <- comparisonNames
names(results_rev) <- comparisonNames_rev
results
results_rev
rm(captureList)
View(WrightFst)
setwd("D:/Programming/R_projects/Kulathinal_Lab/GWASpops.pheno2geno/")
library(GWASpops.pheno2geno)
source("bootCalls2.R")
source("./R/fst_funcs.R")
source("./workingScripts/dataTransform_Fst.R")
load("./WorkingData/GwasAssocitions.rda")
thousGenPops <- Populations[grep("1000GENOMES", Populations$Population_Abbreviation)]
View(load_n_flatten)
View(load_n_flatten)
variantList <- load('./workingData/unprocessedChunks/chunk23301-23430.rds')
variantList <- purrr::flatten(purrr::flatten(retList))
View(variantList)
variantList <- purrr::flatten(retList)
View(variantList)
# compose list then tranform into GWASpops.geno2pheno masterList format
dataList <- list(asso, variantList)
masterList <- ensListTransform_mod(dataList, TRUE)
# calculate Fst, delete redudant data vals, and discard multiallelic sites
fstList <- hudsonFst_alleleList(masterList[[2]], Fst_populations, deleteRedundants = TRUE, discardMultiAllelic =  TRUE)
# calculate Fst, delete redudant data vals, and discard multiallelic sites
fstList <- hudsonFst_alleleList(masterList[[2]], thousGenPops, deleteRedundants = TRUE, discardMultiAllelic =  TRUE)
warnings()
View(fstList)
fstList <- fill_rows(fstList) # making all sublists compatible for binding together as data.frame
View(retList)
View(fstList)
names <- names(fstList)
fstDF <- cbind.data.frame(fstList)
colnames(fstDF) <- names
fstDF <- as.data.frame(t(fstDF)) # transpose s.t. rows are alleles, cols are population-pairs
masterList[['Fst_per_allele']] <- fstDF
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\fst_GWAS_annotation_lists")
fileName <- paste0('fullData_', '234')
save(masterList, file = fileName)
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno")
getwd()
library(GWASpops.pheno2geno)
source("bootCalls2.R")
source("./R/fst_funcs.R")
source("./workingScripts/dataTransform_Fst.R")
load("./WorkingData/GwasAssocitions.rda")
thousGenPops <- Populations[grep("1000GENOMES", Populations$Population_Abbreviation)]
