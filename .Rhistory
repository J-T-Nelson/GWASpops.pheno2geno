alcConsumpAllTransformed <- dbugTransform(alcConsumpAlldata, popsData = T)
library(data.table)
alcConsumpAllTransformed <- dbugTransform(alcConsumpAlldata, popsData = T)
debug(dbugTransform)
alcConsumpAllTransformed <- dbugTransform(alcConsumpAlldata, popsData = T)
View(masterTable)
uniqMasterT[uniqMasterT$EnsVar_name == names(popFreqList[variant]), ]$EnsVar_ancestral_allele
View(uniqMasterT)
rsIds <- uniqMasterT$EnsVar_name
length(unique(rsIds))
attr(popFreqList[variant],
"name")
uniqMasterT[uniqMasterT$EnsVar_name == names(popFreqList[variant]), ]$EnsVar_ancestral_allele
view(masterList)
View(masterTable)
View(masterList)
Populations
alcConsumpAllTransformed <- dbugTransform(alcConsumpAlldata, popsData = T)
alcConsumpAllTransformed <- dbugTransform(alcConsumpAlldata, popsData = T)
alcConsumpAllTransformed <- dbugTransform(alcConsumpAlldata, popsData = T)
View(filteredList)
checkAA <- lapply(filteredList, \(x) attr(x, "Ancestral_Allele"))
lengths <- sapply(checkAA, length)
sum(lengths)
lengths
sum(lengths)
which(lengths <2)
View(filteredList)
filteredList$allele
filteredList[1]$allele
View(filteredList)
filteredList[[1]]$allele
filteredList[[1]]$allele != attr(filteredList[[1]], "Ancestral_Allele")
attr(filteredList[[1]])
attr(filteredList[[1]], "Ancestral_Allele")
IBFVars <- createMT2(GWASdataSets[4], processData = F)
IBFAlldata <- createMT2(GWASdataSets[4], processData = F, population_data = T)
save(IBFVars, file = 'data/debugging_raw_data/IBFVars.rds')
save(IBFAlldata, file = 'data/debugging_raw_data/IBFAlldata.rds')
IntVars <- createMT2(GWASdataSets[5], processData = F)
IntAlldata <- createMT2(GWASdataSets[5], processData = F, population_data = T)
save(IntVars, file = 'data/debugging_raw_data/IntVars.rds') # MARKER... HERE IS WHERE NEW DATA CALLS STOPPED
save(IntAlldata, file = 'data/debugging_raw_data/IntAlldata.rds')
alcConsumpAllTransformed <- dbugTransform(alcConsumpAlldata, popsData = T)
View(popData)
attr(popData[[1]])
attributes(popData[[1]])
View(masterList)
attributes(masterList[[2]][[1]])
sapply(masterList[[2]], \(x) attr(x, "Ancestral_Allele"))
?duplicated
?anyDuplicated
?duplicated
?any
View(alcConsumpAlldata)
length(alcConsumpAllData[[2]][[1]]$mappings)
length(alcConsumpAlldata[[2]][[1]]$mappings)
alcConsumpAlldata[[2]][[1]]$mappings
alcConsumpAlldata[[2]][1$mappings
alcConsumpAlldata[[2]][1]$mappings
alcConsumpAlldata[[2]][1]$mappings
alcConsumpEnsData <- purrr::flatten(alcConsumpAlldata[[2]])
mappingNum <- sapply(alcConsumpEnsData, \(x) length(x$mappings))
mappingG2 <- mappingNum[mappingNum >2]
mappingG2
mappingG2 <- mappingNum[mappingNum > 1]
mappingG2
mappingG2indeces <- which(mappingNum[mappingNum > 1])
mappingG2indeces <- which(mappingNum > 1)
getWeirdMappings <- alcConsumpEnsData[[mappingG2indeces[10:15]]]
getWeirdMappings <- alcConsumpEnsData[mappingG2indeces[10:15]]
View(getWeirdMappings)
getWeirdMappingsAll <- alcConsumpEnsData[mappingG2indeces]
View(getWeirdMappingsAll)
onlyMappings <- lapply(getWeirdMappingsAll, \(x) x$mappings)
View(onlyMappings)
AAlist <- as.list(vector(length = 53))
?pluck
for(i in onlyAA){
subList <- list()
for(ele in 1:length(i)){
subList[ele] <- purrr::pluck(onlyAA[i], "ancestral_allele")
}
AAlist[i] <- subList
}
for(i in onlyMappings){
subList <- list()
for(ele in 1:length(i)){
subList[ele] <- purrr::pluck(onlyMappings[i], "ancestral_allele")
}
AAlist[i] <- subList
}
num = 0
for(i in onlyMappings){
num = num + 1
subList <- list()
for(ele in 1:length(i)){
subList[ele] <- purrr::pluck(onlyMappings[num], "ancestral_allele")
}
AAlist[i] <- subList
}
for(i in onlyMappings){
num = num + 1
subList <- list()
for(ele in 1:length(i)){
subList[ele] <- purrr::pluck(onlyMappings[num], "ancestral_allele")
}
AAlist[num] <- subList
}
warnings()
View(AAlist)
num = 0
for(i in onlyMappings){
num = num + 1
subList <- list()
for(ele in 1:length(i)){
subList[ele] <- purrr::pluck(onlyMappings[num], "ancestral_allele")
}
AAlist[[num]] <- subList
}
View(AAlist)
num = 0
for(i in onlyMappings){
num = num + 1
subList <- list()
for(ele in 1:length(i)){
subList[ele] <- purrr::pluck(onlyMappings[[num]], "ancestral_allele")
}
AAlist[[num]] <- subList
}
View(AAlist)
View(AAlist)
View(AAlist)
a <- pluck(onlyMappings[[1]], 'ancestral_allele')
View(onlyMappings)
a <- pluck(onlyMappings[[1]][[1]], 'ancestral_allele')
num = 0
for(i in onlyMappings){
num = num + 1
subList <- list()
for(ele in 1:length(i)){
subList[ele] <- purrr::pluck(onlyMappings[[num]][[ele]], "ancestral_allele")
}
AAlist[[num]] <- subList
}
View(AAlist)
fAAlist <- flatten(AAlist)
View(fAAlist)
alcConsumpAllTransformed <- dbugTransform(alcConsumpAlldata, popsData = T)
alcConsumpAllTransformed <- dbugTransform(alcConsumpAlldata, popsData = T)
View(filteredList)
View(popFreqList)
alcConsumpAllTransformed <- dbugTransform(alcConsumpAlldata, popsData = T)
View(popData)
View(CONT)
View(popData)
load("data/debugging_raw_data/AirPollutionAlldata.rds")
airPollutionAllTransformed <- dbugTransform(airPollutionAlldata, popsData = T)
airPollutionAllTransformed <- dbugTransform(airPollutionAlldata, popsData = T)
airPollutionAllTransformed <- dbugTransform(AirPollutionAlldata, popsData = T)
View(popData)
undebug(dbugTransform)
airPollutionAllTransformed <- dbugTransform(AirPollutionAlldata, popsData = T)
debug(dbugTransform)
airPollutionAllTransformed <- dbugTransform(AirPollutionAlldata, popsData = T)
airPollutionAllTransformed <- dbugTransform(AirPollutionAlldata, popsData = T)
View(filteredList)
View(filteredList)
?filter
View(masterList)
why am I discarding ancestral alleles from population data once again? ... I think it is because its not interesting to look at ancestral alleles in graphs? Yeah... when graphing a set of variants for a single population... if we graph both the ancestral alleles as well as the alleles which are being reported by a given variantID (as variantIDs describe abnormalities in the genome, and thus a variants ancestral allele is the nucleiotide(s) being replaced.) then the graph doesn't really make sense right away.. as we should hypothetically have 100% of frequency for both ancestral allele and variant allele. Thus we just graph the variant frequency for each allele in a given population to see how frequent the occurence of that variant is in that population.
source("bootCalls.R")
load("data/debugging_raw_data/AirPollutionAlldata.rds")
airPollutionAllTransformed <- dbugTransform(AirPollutionAlldata, popsData = T)
unload('GWASpops.pheno2geno')
devtools::install("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno") # even after unloading my package... it was not able to reload without restarting RStudio.. kind of annoying, but relatively trivial if following best practices.
library(GWASpops.pheno2geno)
airPollutionAllTransformed <- dbugTransform(AirPollutionAlldata, popsData = T)
unload('GWASpops.pheno2geno')
devtools::install("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno") # even after unloading my package... it was not able to reload without restarting RStudio.. kind of annoying, but relatively trivial if following best practices.
devtools::install("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno") # even after unloading my package... it was not able to reload without restarting RStudio.. kind of annoying, but relatively trivial if following best practices.
source('bootCalls.R')
unload('GWASpops.pheno2geno')
devtools::install("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno") # even after unloading my package... it was not able to reload without restarting RStudio.. kind of annoying, but relatively trivial if following best practices.
data.table:::merge.data.table
airPollutionAllTransformed <- dbugTransform(AirPollutionAlldata, popsData = T) # OK still getting error with finding merge.data.table... maybe I will just import `merge` as well?
library(GWASpops.pheno2geno)
load("data/debugging_raw_data/AirPollutionAlldata.rds")
airPollutionAllTransformed <- dbugTransform(AirPollutionAlldata, popsData = T) # OK still getting error with finding merge.data.table... maybe I will just import `merge` as well?
dbugTransform <- function(dataList, popsData = F ) {
CONT <- purrr::flatten(dataList[[2]]) #removing nested structure to have 1 list containing all rsID objects
CONT <- purrr::compact(CONT) # removing empty elements introduced by:
## multiAPIcall_variants2 ... think its one of the for loops that are fixing these data elements: EnsVar_synonyms and EnsVar_Clinical_significance
GWAS_DF <- dataList[[1]] #storing GWAS data from GWAS files for later.. (similar to createMT())
if(popsData){
# grabbing population data and converting into a list of tibbles.
popData <- sapply(CONT, function(x) x$populations)
popData <- lapply(popData, function(x) bind_rows(x))
# removes populations from the response content so further operations proceed properly.
CONT <- lapply(CONT, function(x) x[names(x) != 'populations'])
}
CONT_noMultiMapping <- GWASpops.pheno2geno:::fixMultiMapping(CONT)
CONT_noMultiMapping <- CONT_noMultiMapping[!sapply(CONT_noMultiMapping, is.null)] # this is a quick and dirty solution to the fact that fixMultiMapping() is producing null list entries at the end of its list output. I don't know why this is happening.
CONT_noNULL <- lapply(CONT_noMultiMapping, null2NA_ENSvariants)
CONT_Table <- GWASpops.pheno2geno:::rsTable(CONT_noNULL) #CONT_Table at this point is just EnsVariants. No GWAS data or Pop data.
#renaming cols so their source is evident in the master table.
names(CONT_Table) <- paste0('EnsVar_',names(CONT_Table))
if(popsData){
# setting ancestral allele attribute on population frequency data.
popData <- GWASpops.pheno2geno:::AncestralAllele_attr(CONT_Table, popData)
masterList <- list(CONT_Table, popData)
#return(masterList)
}
#return(CONT_Table)
#---------------createMT calls after here -------------------------
if(popsData){
#var_pop_list <- GWASpops.pheno2geno:::get_ensVariants(GWAS_DF$VariantID, population_data = TRUE)
# merging Variant data with GWAS table data
tryCatch(
expr = {masterTable <- data.table:::merge.data.table(GWAS_DF, masterList[[1]], by.x = 'VariantID', by.y = 'EnsVar_name')},
error = function(e){ # in the case of too many duplicate rows causing the merge to fail
#  initially this option will allow for the merge to proceed.
masterTable <- data.table:::merge.data.table(GWAS_DF, masterList[[1]], by.x = 'VariantID', by.y = 'EnsVar_name', allow.cartesian = T);
message("merge.data.table performed with `allow.cartesian = TRUE`, therefore many extra rows may
be produced with many possibly being duplicated rows due to duplicates in the tables being merged.")
}
)
# Transforming data for single population based data tables
singlePop_alleleFreqDTs <- lapply(Populations$Population_Abbreviation,
function(x) GWASpops.pheno2geno:::singlePopTransform(masterList[[2]], targetPopulation = x))
# Populations is a data object that comes with the package. (see ?Populations for more information or inspect the object itself.)
names(singlePop_alleleFreqDTs) <- Populations$Population_Abbreviation
masterListFinal <- list(masterTable, masterList[[2]], singlePop_alleleFreqDTs)
names(masterListFinal) <- c('masterTable', 'PopAlleleFreqData', 'singlePop_alleleFreqDTs')
return(masterListFinal)######## END for pops
}
# DEBUGGING RETURN:
#   return(list(GWAS_DF, CONT_Table))
# only variant data ------------------------
# Merging Ensembl variant and GWAS tables
tryCatch(
expr = {masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name')},
error = function(e){ # in the case of too many duplicate rows causing the merge to fail initially this option will allow for the merge to proceed.
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name', allow.cartesian = T);
message("merge.data.table performed with `allow.cartesian = TRUE`, therefore many extra rows may be produced with many possibly being duplicated rows due to duplicates in the tables being merged.")
}
)
return(masterTable) ######### END for vars
}
d
airPollutionAllTransformed <- dbugTransform(AirPollutionAlldata, popsData = T) # OK still getting error with finding merge.data.table... maybe I will just import `merge` as well?
airPollutionAllTransformed <- dbugTransform(AirPollutionAlldata, popsData = T)
alcConsumpEnsData <- purrr::flatten(alcConsumpAlldata[[2]])
airPollTest <- createMT('exampleData/air_pollution', population_data = T)
# TESTING BASE FUNCTIONS...
library(data.table)
airPollTest <- createMT('exampleData/air_pollution', population_data = T)
View(singlePopTransform)
dbugTransform <- function(dataList, popsData = F ) {
CONT <- purrr::flatten(dataList[[2]]) #removing nested structure to have 1 list containing all rsID objects
CONT <- purrr::compact(CONT) # removing empty elements introduced by:
## multiAPIcall_variants2 ... think its one of the for loops that are fixing these data elements: EnsVar_synonyms and EnsVar_Clinical_significance
GWAS_DF <- dataList[[1]] #storing GWAS data from GWAS files for later.. (similar to createMT())
if(popsData){
# grabbing population data and converting into a list of tibbles.
popData <- sapply(CONT, function(x) x$populations)
popData <- lapply(popData, function(x) bind_rows(x))
# removes populations from the response content so further operations proceed properly.
CONT <- lapply(CONT, function(x) x[names(x) != 'populations'])
}
CONT_noMultiMapping <- GWASpops.pheno2geno:::fixMultiMapping(CONT)
CONT_noMultiMapping <- CONT_noMultiMapping[!sapply(CONT_noMultiMapping, is.null)] # this is a quick and dirty solution to the fact that fixMultiMapping() is producing null list entries at the end of its list output. I don't know why this is happening.
CONT_noNULL <- lapply(CONT_noMultiMapping, null2NA_ENSvariants)
CONT_Table <- GWASpops.pheno2geno:::rsTable(CONT_noNULL) #CONT_Table at this point is just EnsVariants. No GWAS data or Pop data.
#renaming cols so their source is evident in the master table.
names(CONT_Table) <- paste0('EnsVar_',names(CONT_Table))
if(popsData){
# setting ancestral allele attribute on population frequency data.
popData <- GWASpops.pheno2geno:::AncestralAllele_attr(CONT_Table, popData)
masterList <- list(CONT_Table, popData)
#return(masterList)
}
#return(CONT_Table)
#---------------createMT calls after here -------------------------
if(popsData){
#var_pop_list <- GWASpops.pheno2geno:::get_ensVariants(GWAS_DF$VariantID, population_data = TRUE)
# merging Variant data with GWAS table data
tryCatch(
expr = {masterTable <- data.table:::merge.data.table(GWAS_DF, masterList[[1]], by.x = 'VariantID', by.y = 'EnsVar_name')},
error = function(e){ # in the case of too many duplicate rows causing the merge to fail
#  initially this option will allow for the merge to proceed.
masterTable <- data.table:::merge.data.table(GWAS_DF, masterList[[1]], by.x = 'VariantID', by.y = 'EnsVar_name', allow.cartesian = T);
message("merge.data.table performed with `allow.cartesian = TRUE`, therefore many extra rows may
be produced with many possibly being duplicated rows due to duplicates in the tables being merged.")
}
)
return(masterList) # TEMP RETURN FOR DEBUGGING
# Transforming data for single population based data tables
singlePop_alleleFreqDTs <- lapply(Populations$Population_Abbreviation,
function(x) GWASpops.pheno2geno:::singlePopTransform(masterList[[2]], targetPopulation = x))
# Populations is a data object that comes with the package. (see ?Populations for more information or inspect the object itself.)
names(singlePop_alleleFreqDTs) <- Populations$Population_Abbreviation
masterListFinal <- list(masterTable, masterList[[2]], singlePop_alleleFreqDTs)
names(masterListFinal) <- c('masterTable', 'PopAlleleFreqData', 'singlePop_alleleFreqDTs')
return(masterListFinal)######## END for pops
}
# DEBUGGING RETURN:
#   return(list(GWAS_DF, CONT_Table))
# only variant data ------------------------
# Merging Ensembl variant and GWAS tables
tryCatch(
expr = {masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name')},
error = function(e){ # in the case of too many duplicate rows causing the merge to fail initially this option will allow for the merge to proceed.
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name', allow.cartesian = T);
message("merge.data.table performed with `allow.cartesian = TRUE`, therefore many extra rows may be produced with many possibly being duplicated rows due to duplicates in the tables being merged.")
}
)
return(masterTable) ######### END for vars
}
airPollutionTempReturn <- dbugTransform(AirPollutionAlldata, popsData = T)
debug(createMT)
airPollTest <- createMT('exampleData/air_pollution', population_data = T)
varPop2 <- var_pop_list[[2]]
View(varPop2)
View(airPollutionTempReturn)
airPol2 <- airPollutionTempReturn[[2]]
View(airPol2)
View(singlePopTable)
View(filteredList)
dbugTransform <- function(dataList, popsData = F ) {
CONT <- purrr::flatten(dataList[[2]]) #removing nested structure to have 1 list containing all rsID objects
CONT <- purrr::compact(CONT) # removing empty elements introduced by:
## multiAPIcall_variants2 ... think its one of the for loops that are fixing these data elements: EnsVar_synonyms and EnsVar_Clinical_significance
GWAS_DF <- dataList[[1]] #storing GWAS data from GWAS files for later.. (similar to createMT())
if(popsData){
# grabbing population data and converting into a list of tibbles.
popData <- sapply(CONT, function(x) x$populations)
popData <- lapply(popData, function(x) bind_rows(x))
# removes populations from the response content so further operations proceed properly.
CONT <- lapply(CONT, function(x) x[names(x) != 'populations'])
}
CONT_noMultiMapping <- GWASpops.pheno2geno:::fixMultiMapping(CONT)
CONT_noMultiMapping <- CONT_noMultiMapping[!sapply(CONT_noMultiMapping, is.null)] # this is a quick and dirty solution to the fact that fixMultiMapping() is producing null list entries at the end of its list output. I don't know why this is happening.
CONT_noNULL <- lapply(CONT_noMultiMapping, null2NA_ENSvariants)
CONT_Table <- GWASpops.pheno2geno:::rsTable(CONT_noNULL) #CONT_Table at this point is just EnsVariants. No GWAS data or Pop data.
#renaming cols so their source is evident in the master table.
names(CONT_Table) <- paste0('EnsVar_',names(CONT_Table))
if(popsData){
# setting ancestral allele attribute on population frequency data.
popData <- GWASpops.pheno2geno:::AncestralAllele_attr(CONT_Table, popData)
masterList <- list(CONT_Table, popData)
#return(masterList)
}
#return(CONT_Table)
#---------------createMT calls after here -------------------------
if(popsData){
#var_pop_list <- GWASpops.pheno2geno:::get_ensVariants(GWAS_DF$VariantID, population_data = TRUE)
# merging Variant data with GWAS table data
tryCatch(
expr = {masterTable <- data.table:::merge.data.table(GWAS_DF, masterList[[1]], by.x = 'VariantID', by.y = 'EnsVar_name')},
error = function(e){ # in the case of too many duplicate rows causing the merge to fail
#  initially this option will allow for the merge to proceed.
masterTable <- data.table:::merge.data.table(GWAS_DF, masterList[[1]], by.x = 'VariantID', by.y = 'EnsVar_name', allow.cartesian = T);
message("merge.data.table performed with `allow.cartesian = TRUE`, therefore many extra rows may
be produced with many possibly being duplicated rows due to duplicates in the tables being merged.")
}
)
#  return(masterList) # TEMP RETURN FOR DEBUGGING
# Transforming data for single population based data tables
singlePop_alleleFreqDTs <- lapply(Populations$Population_Abbreviation,
function(x) GWASpops.pheno2geno:::singlePopTransform(masterList[[2]], targetPopulation = x))
# Populations is a data object that comes with the package. (see ?Populations for more information or inspect the object itself.)
names(singlePop_alleleFreqDTs) <- Populations$Population_Abbreviation
masterListFinal <- list(masterTable, masterList[[2]], singlePop_alleleFreqDTs)
names(masterListFinal) <- c('masterTable', 'PopAlleleFreqData', 'singlePop_alleleFreqDTs')
return(masterListFinal)######## END for pops
}
# DEBUGGING RETURN:
#   return(list(GWAS_DF, CONT_Table))
# only variant data ------------------------
# Merging Ensembl variant and GWAS tables
tryCatch(
expr = {masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name')},
error = function(e){ # in the case of too many duplicate rows causing the merge to fail initially this option will allow for the merge to proceed.
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name', allow.cartesian = T);
message("merge.data.table performed with `allow.cartesian = TRUE`, therefore many extra rows may be produced with many possibly being duplicated rows due to duplicates in the tables being merged.")
}
)
return(masterTable) ######### END for vars
}
airPollutionAllTransformed <- dbugTransform(AirPollutionAlldata, popsData = T)
source('bootCalls.R')
load("data/debugging_raw_data/AirPollutionAlldata.rds")
airPollutionAllTransformed <- dbugTransform(AirPollutionAlldata, popsData = T)
airPollutionAllTransformed <- dbugTransform(AirPollutionAlldata, popsData = T)
unload('GWASpops.pheno2geno')
devtools::install("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno") # even after unloading my package... it was not able to reload without restarting RStudio.. kind of annoying, but relatively trivial if following best practices.
library(GWASpops.pheno2geno)
airPollutionAllTransformed <- dbugTransform(AirPollutionAlldata, popsData = T)
rm(createMT2, dbugTransform, get_ensVariants2, multiAPIcall_variants2)
airPollutionAllTransformed <- dbugTransform(AirPollutionAlldata, popsData = T)
source('bootCalls.R')
load("data/debugging_raw_data/AirPollutionAlldata.rds")
airPollutionAllTransformed <- dbugTransform(AirPollutionAlldata, popsData = T)
airPollTest <- createMT('exampleData/air_pollution', population_data = T) # THIS SUCCEEDED WITHOUT DEBUGGER, but GOT STUCK IN THE SAME INIFINITE LOOP AS OUR `dbugTransform()` WHEN IN THE DEBUGGER.
airPollutionAllTransformed <- dbugTransform(AirPollutionAlldata, popsData = T)
load("data/debugging_raw_data/alcConsumpAlldata.rds")
alcConsumpAllTransformed <- dbugTransform(alcConsumpAlldata, popsData = T)
debug(dbugTransform)
alcConsumpAllTransformed <- dbugTransform(alcConsumpAlldata, popsData = T)
View(filteredList)
sapply(filteredList, \(x) attr(x, "Ancestral_Allele"))
attributes <- sapply(filteredList, \(x) attr(x, "Ancestral_Allele"))
View(attributes)
alcConsumpAllTransformed <- dbugTransform(alcConsumpAlldata, popsData = T)
View(masterTable)
View(uniqMasterT)
uniqMasterT[uniqMasterT$EnsVar_name == names(popFreqList[1]), ]$EnsVar_ancestral_allele
uniqMasterT[uniqMasterT$EnsVar_name == names(popFreqList[1]), ]
names(popFreqList[1])
duplicated(masterTable$EnsVar_name)
duplicates <- duplicated(masterTable$EnsVar_name)
sum(duplicates)
rows <- uniqMasterT[uniqMasterT$EnsVar_name == names(popFreqList[1]), ]
View(rows)
names(popFreqList[1])
length(uniqMasterT$EnsVar_name == names(popFreqList[1]))
sum(uniqMasterT$EnsVar_name == names(popFreqList[1]))
matches <- uniqMasterT$EnsVar_name == names(popFreqList[1])
sum(matches)
any(matches, T)
?any
any(matches)
class(matches)
sum(duplicates)
sum(matches)
is.na(matches)
maybeNA <- is.na(matches)
identical(maybeNA, matches)
sum(maybeNA)
is.na(uniqMasterT$EnsVar_name)
nainMaster <- is.na(uniqMasterT$EnsVar_name)
sum(nainMaster)
fixMT <- uniqMasterT[!is.na(uniqMasterT$EnsVar_name)]
fixMT <- uniqMasterT[!is.na(uniqMasterT$EnsVar_name), ]
uniqMasterT <- fixMT
warnings()
View(singlePop_alleleFreqDTs)
unload('GWASpops.pheno2geno')
devtools::install("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno") # even after unloading my package... it was not able to reload without restarting RStudio.. kind of annoying, but relatively trivial if following best practices.
library(GWASpops.pheno2geno)
detach("package:GWASpops.pheno2geno", unload = TRUE)
library(GWASpops.pheno2geno)
# post fix stated above ^^
alcConsumpAllTransformed2 <- dbugTransform(alcConsumpAlldata, popsData = T)
View(alcConsumpAlldata)
# post fix stated above ^^
alcConsumpPopDataReduced <- alConsumpAllData[[2]][[1:2]]
# post fix stated above ^^
alcConsumpPopDataReduced <- alcConsumpAllData[[2]][[1:2]]
# post fix stated above ^^
alcConsumpPopDataReduced <- alcConsumpAlldata[[2]][[1:2]]
alcConsumpPopDataReduced <- list(alcConsumpAlldata[[1]],alcConsumpPopDataReduced)
View(alcConsumpPopDataReduced)
# post fix stated above ^^
alcConsumpPopDataReduced <- alcConsumpAlldata[[2]][[1:2]]
View(alcConsumpAlldata)
# post fix stated above ^^
alcConsumpPopDataReduced <- alcConsumpAlldata[[2]][[1]]
View(alcConsumpPopDataReduced)
alcConsumpPopDataReduced <- list(alcConsumpAlldata[[1]],alcConsumpPopDataReduced)
View(alcConsumpPopDataReduced)
alcConsumpAllTransformed2 <- dbugTransform(alcConsumpAlldata, popsData = T)
alcConsumpAllTransformed2 <- dbugTransform(alcConsumpPopDataReduced, popsData = T)
alcConsumpAllTransformed2 <- dbugTransform(alcConsumpPopDataReduced, popsData = T)
View(alcConsumpPopDataReduced)
# post fix stated above ^^
a <- alcConsumpAlldata[[2]][[1]]
b <- alcConsumpAlldata[[2]][[2]]
alcConsumpPopDataReduced <- list(a,b) # grabbing a single sublist.. reducing the amount of Ensembl data by 10x
alcConsumpPopDataReduced <- list(alcConsumpAlldata[[1]],alcConsumpPopDataReduced)
View(alcConsumpPopDataReduced)
alcConsumpAllTransformed2 <- dbugTransform(alcConsumpPopDataReduced, popsData = T)
lungCancerVars <- createMT2(GWASdataSets[6], processData = F)
lungCancerAlldata <- createMT2(GWASdataSets[6], processData = F, population_data = T)
malabsorptionSyndVars <- createMT2(GWASdataSets[7], processData = F)
malabsorptionSyndAlldata <- createMT2(GWASdataSets[7], processData = F, population_data = T)
save(lungCancerVars, file = 'data/debugging_raw_data/lungCancerVars.rds')
save(lungCancerAlldata, file = 'data/debugging_raw_data/lungCancerAlldata.rds')
save(malabsorptionSyndVars, file = 'data/debugging_raw_data/malabsorptionSyndVars.rds')
save(malabsorptionSyndAlldata, file = 'data/debugging_raw_data/malabsorptionSyndAlldata.rds')
neuroticismVars <- createMT2(GWASdataSets[8], processData = F)
neuroticismAlldata <- createMT2(GWASdataSets[8], processData = F, population_data = T)
save(neuroticismVars, file = 'data/debugging_raw_data/neuroticismVars.rds')# MARKER... HERE IS WHERE NEW DATA CALLS STOPPED
save(neuroticismAlldata, file = 'data/debugging_raw_data/neuroticismAlldata.rds')
prostateCancerVars <- createMT2(GWASdataSets[9], processData = F)
prostateCancerAlldata <- createMT2(GWASdataSets[9], processData = F, population_data = T)
save(prostateCancerAlldata, file = 'data/debugging_raw_data/prostateCancerAlldata.rds')
substanceAbuseVars <- createMT2(GWASdataSets[10], processData = F)
substanceAbuseAlldata <- createMT2(GWASdataSets[10], processData = F, population_data = T)
AirPollutionVars <- createMT2('exampleData/air_pollution', processData = F)
AirPollutionAlldata <- createMT2('exampleData/air_pollution', processData = F, population_data = T)
save(substanceAbuseVars, file = 'data/debugging_raw_data/substanceAbuseVars.rds')# MARKER... HERE IS WHERE NEW DATA CALLS STOPPED
save(substanceAbuseAlldata, file = 'data/debugging_raw_data/substanceAbuseAlldata.rds')
save(AirPollutionVars, file = 'data/debugging_raw_data/AirPollutionVars.rds')
save(AirPollutionAlldata, file = 'data/debugging_raw_data/AirPollutionAlldata.rds')
load("data/debugging_raw_data/alcConsumpVars.rds")
source('bootCalls.R')
alcConsumpAllTrans <- dbugTransform(alcConsumpAlldata, popsData = T)
alcConsumpVarTrans <- dbugTransform(alcConsumpVars)
load("data/debugging_raw_data/alcConsumpAlldata.rds")
alcConsumpAllTrans <- dbugTransform(alcConsumpAlldata, popsData = T)
