View(rh)
rh <- list()
r1 <- list( 'g', 'gg', 5)
r2 <- list('good', 5 , 6)
rh <- list( r1, r2)
rh <- list(rh, r1, r2)
View(rh)
rh <- list()
r1 <- list( 'g', 'gg', 5)
r2 <- list('good', 5 , 6)
rh <- list( r1, r2)
?append
rh[["ham1"]] <- dummyRow
rh[["hammm"]] <- dummyRow
rh[["hammgf"]] <- r1
rh
View(rh)
rh <- list()
rh[["ham1"]] <- dummyRow
rh[["hammm"]] <- dummyRow
rh[["hammgf"]] <- r1
View(rh)
rh <- list()
rh[["ham1"]] <- dummyRow
rh[["hammm"]] <- dummyRow
# thinking that a named list is ideal... then each row will carry the name with it.. we still need to name cols though.
rhdf <- dplyr::bind_rows(rh)
View(rhdf)
# thinking that a named list is ideal... then each row will carry the name with it.. we still need to name cols though.
rhdf <- dplyr::bind_cols(rh)
# thinking that a named list is ideal... then each row will carry the name with it.. we still need to name cols though.
rhdf_row <- dplyr::bind_row(rh)
# thinking that a named list is ideal... then each row will carry the name with it.. we still need to name cols though.
rhdf_row <- dplyr::bind_rows(rh)
rhdf_col <- dplyr::bind_cols(rh)
t(rhdf)
# thinking that a named list is ideal... then each row will carry the name with it.. we still need to name cols though.
rhdf <- dplyr::bind_rows(rh)
rhdfFinal <- t(rhdf)
rhdfFinal <- as.data.frame(t(rhdf)) # its a fucking character vec
View(rhdfFinal)
?bind_rows
names(rhdfFinal) <- c("Pair", 'n1', "p1", 'n2', 'p2')
rhdfFinal
describe(rhdfFinal)
str(rhdfFinal)
rhdfFinal['pop_pair'] <- as.numeric(rhdfFinal['pop_pair'])
names(rhdfFinal) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
rhdfFinal['pop_pair'] <- as.numeric(rhdfFinal['pop_pair'])
View(rhdfFinal)
str(rhdfFinal) # bunch of character vecs
View(perAlleleFst_transform)
rhdfFinal['pop_pair'] <- as.numeric(rhdfFinal['pop_pair'])
rhdfFinal['pop_pair'] <- as.numeric(rhdfFinal[['pop_pair']])
View(rhdfFinal)
# thinking that a named list is ideal... then each row will carry the name with it.. we still need to name cols though.
rhdf <- dplyr::bind_rows(rh)
rhdfFinal <- as.data.frame(t(rhdf)) # its a fucking character vec
names(rhdfFinal) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
rhdfFinal
str(rhdfFinal) # bunch of character vecs
rhdfFinal['n1'] <- as.numeric(rhdfFinal[['n1']])
rhdfFinal
str(rhdfFinal)
rhdfFinal['n2'] <- as.numeric(rhdfFinal[['n2']])
rhdfFinal['p1'] <- as.numeric(rhdfFinal[['p1']])
rhdfFinal['p2'] <- as.numeric(rhdfFinal[['p2']])
str(rhdfFinal)
View(rhdfFinal)
perAlleleFst_transform <- function(alleleDF, populations){
# Extract data of interest from alleleDF
ancestralAllele <- attr(alleleDF, "Ancestral_Allele")
alleleDF <- alleleDF[alleleDF$population %in% populations & alleleDF$allele != ancestralAllele]
# Digest DF in to create DF out:
DF_rows <- nrow(alleleDF)
rowHolder <- list()
for(i in 1:DF_rows){ # i correlates to a population
for(j in (1+i):DF_rows){ # j correlates to the second population used to pair with i's population
rName <- paste0(alleleDF$population[i], "-X-",alleleDF$population[j])
row <- c(rName,
populations[populations$Population_Abbreviation == alleleDF$population[i]$Sample_Count],
alleleDF$frequency[i],
populations[populations$Population_Abbreviation == alleleDF$population[j]$Sample_Count],
alleleDF$frequency[j])
rowHolder[[rName]] <- row
}
}
#setup return DF, name cols, fix col types, assign attributes
retDF <- as.data.frame(t(dplyr::bind_rows(rowHolder)))
names(retDF) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
retDF['n1'] <- as.numeric(retDF[['n1']])
retDF['n2'] <- as.numeric(retDF[['n2']])
retDF['p1'] <- as.numeric(retDF[['p1']])
retDF['p2'] <- as.numeric(retDF[['p2']])
attr(retDF, "Ancestral_Allele") <- ancestralAllele
attr(retDF, "VariantID") <- attr(alleleDF, "VariantID")
return(retDF)
}
perAlleleFst_transform <- function(alleleDF, populations){
# Extract data of interest from alleleDF
ancestralAllele <- attr(alleleDF, "Ancestral_Allele")
alleleDF <- alleleDF[alleleDF$population %in% populations$Population_Abbreviation & alleleDF$allele != ancestralAllele]
# Digest DF in to create DF out:
DF_rows <- nrow(alleleDF)
rowHolder <- list()
for(i in 1:DF_rows){ # i correlates to a population
for(j in (1+i):DF_rows){ # j correlates to the second population used to pair with i's population
rName <- paste0(alleleDF$population[i], "-X-",alleleDF$population[j])
row <- c(rName,
populations[populations$Population_Abbreviation == alleleDF$population[i]$Sample_Count],
alleleDF$frequency[i],
populations[populations$Population_Abbreviation == alleleDF$population[j]$Sample_Count],
alleleDF$frequency[j])
rowHolder[[rName]] <- row
}
}
#setup return DF, name cols, fix col types, assign attributes
retDF <- as.data.frame(t(dplyr::bind_rows(rowHolder)))
names(retDF) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
retDF['n1'] <- as.numeric(retDF[['n1']])
retDF['n2'] <- as.numeric(retDF[['n2']])
retDF['p1'] <- as.numeric(retDF[['p1']])
retDF['p2'] <- as.numeric(retDF[['p2']])
attr(retDF, "Ancestral_Allele") <- ancestralAllele
attr(retDF, "VariantID") <- attr(alleleDF, "VariantID")
return(retDF)
}
perAlleleFst_transform <- function(alleleDF, populations){
# Extract data of interest from alleleDF
ancestralAllele <- attr(alleleDF, "Ancestral_Allele")
alleleDF <- alleleDF[alleleDF$population %in% populations$Population_Abbreviation & alleleDF$allele != ancestralAllele]
# Digest DF in to create DF out:
DF_rows <- nrow(alleleDF) # number for efficient pairwise iteration
rowHolder <- list()
for(i in 1:DF_rows){ # i correlates to a population
for(j in (1+i):DF_rows){ # j correlates to the second population used to pair with i's population
rName <- paste0(alleleDF$population[i], "-X-",alleleDF$population[j])
row <- c(rName,
populations[populations$Population_Abbreviation == alleleDF$population[i]$Sample_Count],
alleleDF$frequency[i],
populations[populations$Population_Abbreviation == alleleDF$population[j]$Sample_Count],
alleleDF$frequency[j])
rowHolder[[rName]] <- row
}
}
#setup return DF, name cols, fix col types, assign attributes
retDF <- as.data.frame(t(dplyr::bind_rows(rowHolder)))
names(retDF) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
retDF['n1'] <- as.numeric(retDF[['n1']])
retDF['n2'] <- as.numeric(retDF[['n2']])
retDF['p1'] <- as.numeric(retDF[['p1']])
retDF['p2'] <- as.numeric(retDF[['p2']])
attr(retDF, "Ancestral_Allele") <- ancestralAllele
attr(retDF, "VariantID") <- attr(alleleDF, "VariantID")
return(retDF)
}
hudmoPrep <- perAlleleFst_transform(perAllele_1, thousGenPops)
perAlleleFst_transform <- function(alleleDF, populations){
# Extract data of interest from alleleDF
ancestralAllele <- attr(alleleDF, "Ancestral_Allele")
alleleDF <- alleleDF[alleleDF$population %in% populations$Population_Abbreviation & alleleDF$allele != ancestralAllele , ]
# Digest DF in to create DF out:
DF_rows <- nrow(alleleDF) # number for efficient pairwise iteration
rowHolder <- list()
for(i in 1:DF_rows){ # i correlates to a population
for(j in (1+i):DF_rows){ # j correlates to the second population used to pair with i's population
rName <- paste0(alleleDF$population[i], "-X-",alleleDF$population[j])
row <- c(rName,
populations[populations$Population_Abbreviation == alleleDF$population[i]$Sample_Count],
alleleDF$frequency[i],
populations[populations$Population_Abbreviation == alleleDF$population[j]$Sample_Count],
alleleDF$frequency[j])
rowHolder[[rName]] <- row
}
}
#setup return DF, name cols, fix col types, assign attributes
retDF <- as.data.frame(t(dplyr::bind_rows(rowHolder)))
names(retDF) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
retDF['n1'] <- as.numeric(retDF[['n1']])
retDF['n2'] <- as.numeric(retDF[['n2']])
retDF['p1'] <- as.numeric(retDF[['p1']])
retDF['p2'] <- as.numeric(retDF[['p2']])
attr(retDF, "Ancestral_Allele") <- ancestralAllele
attr(retDF, "VariantID") <- attr(alleleDF, "VariantID")
return(retDF)
}
perAlleleFst_transform <- function(alleleDF, populations){
# Extract data of interest from alleleDF
ancestralAllele <- attr(alleleDF, "Ancestral_Allele")
alleleDF <- alleleDF[alleleDF$population %in% populations$Population_Abbreviation & alleleDF$allele != ancestralAllele , ]
# Digest DF in to create DF out:
DF_rows <- nrow(alleleDF) # number for efficient pairwise iteration
rowHolder <- list()
for(i in 1:DF_rows){ # i correlates to a population
for(j in (1+i):DF_rows){ # j correlates to the second population used to pair with i's population
rName <- paste0(alleleDF$population[i], "-X-",alleleDF$population[j])
row <- c(rName,
populations[populations$Population_Abbreviation == alleleDF$population[i]$Sample_Count],
alleleDF$frequency[i],
populations[populations$Population_Abbreviation == alleleDF$population[j]$Sample_Count],
alleleDF$frequency[j])
rowHolder[[rName]] <- row
}
}
#setup return DF, name cols, fix col types, assign attributes
retDF <- as.data.frame(t(dplyr::bind_rows(rowHolder)))
names(retDF) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
retDF['n1'] <- as.numeric(retDF[['n1']])
retDF['n2'] <- as.numeric(retDF[['n2']])
retDF['p1'] <- as.numeric(retDF[['p1']])
retDF['p2'] <- as.numeric(retDF[['p2']])
attr(retDF, "Ancestral_Allele") <- ancestralAllele
attr(retDF, "VariantID") <- attr(alleleDF, "VariantID")
return(retDF)
}
hudmoPrep <- perAlleleFst_transform(perAllele_1, thousGenPops)
hudmoPrep <- perAlleleFst_transform(perAllele_1, thousGenPops)
debug(perAlleleFst_transform)
hudmoPrep <- perAlleleFst_transform(perAllele_1, thousGenPops)
View(alleleDF)
hudmoPrep <- perAlleleFst_transform(perAllele_1, thousGenPops)
class(alleleDF)
class(populations)
hudmoPrep <- perAlleleFst_transform(perAllele_1, thousGenPops)
perAlleleFst_transform <- function(alleleDF, populations){
# Extract data of interest from alleleDF
ancestralAllele <- attr(alleleDF, "Ancestral_Allele")
alleleDF <- alleleDF[alleleDF$population %in% populations$Population_Abbreviation & alleleDF$allele != ancestralAllele , ]
# Digest DF in to create DF out:
DF_rows <- nrow(alleleDF) # number for efficient pairwise iteration
rowHolder <- list()
for(i in 1:DF_rows){ # i correlates to a population
for(j in (1+i):DF_rows){ # j correlates to the second population used to pair with i's population
rName <- paste0(alleleDF$population[i], "-X-",alleleDF$population[j])
row <- c(rName,
populations[populations$Population_Abbreviation == alleleDF$population[i]]$Sample_Count,
alleleDF$frequency[i],
populations[populations$Population_Abbreviation == alleleDF$population[j]]$Sample_Count,
alleleDF$frequency[j])
rowHolder[[rName]] <- row
}
}
#setup return DF, name cols, fix col types, assign attributes
retDF <- as.data.frame(t(dplyr::bind_rows(rowHolder)))
names(retDF) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
retDF['n1'] <- as.numeric(retDF[['n1']])
retDF['n2'] <- as.numeric(retDF[['n2']])
retDF['p1'] <- as.numeric(retDF[['p1']])
retDF['p2'] <- as.numeric(retDF[['p2']])
attr(retDF, "Ancestral_Allele") <- ancestralAllele
attr(retDF, "VariantID") <- attr(alleleDF, "VariantID")
return(retDF)
}
undebug(perAlleleFst_transform)
hudmoPrep <- perAlleleFst_transform(perAllele_1, thousGenPops)
debug(perAlleleFst_transform)
hudmoPrep <- perAlleleFst_transform(perAllele_1, thousGenPops)
View(rowHolder)
rowHolder[["1000GENOMES:phase_3:ACB-X-1000GENOMES:phase_3:AFR"]]
View(rowHolder)
choose(30,2)
sum(nrows(unique(rowHolder)))
uni <- unique(rowHolder)
df <- as.data.frame(rowHolder)
?as.data.frame
df <- dplyr::bind_rows(rowHolder)
?lengths
fiveLenList <- rowHolder[lengths(rowHolder) == 5]
perAlleleFst_transform <- function(alleleDF, populations){
# Extract data of interest from alleleDF
ancestralAllele <- attr(alleleDF, "Ancestral_Allele")
alleleDF <- alleleDF[alleleDF$population %in% populations$Population_Abbreviation & alleleDF$allele != ancestralAllele , ]
# Digest DF in to create DF out:
DF_rows <- nrow(alleleDF) # number for efficient pairwise iteration
rowHolder <- list()
for(i in 1:(DF_rows-1)){ # i correlates to a population
for(j in (1+i):DF_rows){ # j correlates to the second population used to pair with i's population
rName <- paste0(alleleDF$population[i], "-X-",alleleDF$population[j])
row <- c(rName,
populations[populations$Population_Abbreviation == alleleDF$population[i]]$Sample_Count,
alleleDF$frequency[i],
populations[populations$Population_Abbreviation == alleleDF$population[j]]$Sample_Count,
alleleDF$frequency[j])
rowHolder[[rName]] <- row
}
}
#setup return DF, name cols, fix col types, assign attributes
retDF <- as.data.frame(t(dplyr::bind_rows(rowHolder)))
names(retDF) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
retDF['n1'] <- as.numeric(retDF[['n1']])
retDF['n2'] <- as.numeric(retDF[['n2']])
retDF['p1'] <- as.numeric(retDF[['p1']])
retDF['p2'] <- as.numeric(retDF[['p2']])
attr(retDF, "Ancestral_Allele") <- ancestralAllele
attr(retDF, "VariantID") <- attr(alleleDF, "VariantID")
return(retDF)
}
hudmoPrep <- perAlleleFst_transform(perAllele_1, thousGenPops)
View(hudmoPrep)
# no assignment should make for faster calculation on large data sets.
HudsonFst <- function(n1, n2, p1, p2){
return( ((p1-p2)**2 - (p1*(1-p1))/(n1-1) - (p2*(1-p2))/(n2-1)) / (p1*(1-p2) + p2*(1-p1)) )
}
fstCol <- sapply(hudmoPrep, \(x) HudsonFst(x$n1, x$n2, x$p1, x$p2))
View(hudmoPrep)
hudmoPrep[1,2]
hudmoPrep[1,1]
fstCol <- apply(hudmoPrep, 1, \(x) HudsonFst(x[,2], x[,4], x[,3], x[,5]))
rowSubset <- hudmoPreop[1,]
rowSubset <- hudmoPrep[1,]
str(rowSubset)
#   Positional arguments for sake of apply usage
hFst_applyWrapper <- function(alleleDF_row) {
return(HudsonFst(alleleDF_row[2], alleleDF_row[4], alleleDF_row[3], alleleDF_row[5]))
}
fstCol <- apply(hudmoPrep, 1, hFst_applyWrapper)
View(HudsonFst)
apply
?apply
hFst_applyWrapper(hudmoPrep[1,])
tret <- hFst_applyWrapper(hudmoPrep[1,])
class(tret)
tHudsFST <- HudsonFst(hudmoPrep[1,2],hudmoPrep[1,4],hudmoPrep[1,3],hudmoPrep[1,5])
tHudsFST
# no assignment should make for faster calculation on large data sets.
HudsonFst <- function(n1, n2, p1, p2){
return( ( ((p1-p2)**2) - (p1*(1-p1))/(n1-1) - (p2*(1-p2))/(n2-1)) / (p1*(1-p2) + p2*(1-p1)) )
}
tHudsFST <- HudsonFst(hudmoPrep[1,2],hudmoPrep[1,4],hudmoPrep[1,3],hudmoPrep[1,5])
tHudsFST # properly returning just a number.. however it is a negative number which makes me wonder if my function has been written correctly
tret[2]
rowSubset[2]
hudmoPrep[1,1]
class(hudmoPrep[1,1])
?append
fstVec <- numeric(length(hudmoPrep))
fstVec <- numeric(nrow(hudmoPrep))
for(i in 1:nrow(hudmoPrep)){
fstVec[i] <- HudsonFst(hudmoPrep[i,2],hudmoPrep[i,4],hudmoPrep[i,3],hudmoPrep[i,5])
}
perAlleleFst_transform <- function(alleleDF, populations, deleteRedundants = FALSE){
# Extract data of interest from alleleDF
ancestralAllele <- attr(alleleDF, "Ancestral_Allele")
alleleDF <- alleleDF[alleleDF$population %in% populations$Population_Abbreviation & alleleDF$allele != ancestralAllele , ]
# Digest DF in to create DF out:
DF_rows <- nrow(alleleDF) # number for efficient pairwise iteration
rowHolder <- list()
for(i in 1:(DF_rows-1)){ # i correlates to a population
for(j in (1+i):DF_rows){ # j correlates to the second population used to pair with i's population
rName <- paste0(alleleDF$population[i], "-X-",alleleDF$population[j])
row <- c(rName,
populations[populations$Population_Abbreviation == alleleDF$population[i]]$Sample_Count,
alleleDF$frequency[i],
populations[populations$Population_Abbreviation == alleleDF$population[j]]$Sample_Count,
alleleDF$frequency[j])
rowHolder[[rName]] <- row
}
}
#setup return DF, name cols, fix col types, assign attributes
retDF <- as.data.frame(t(dplyr::bind_rows(rowHolder)))
names(retDF) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
retDF['n1'] <- as.numeric(retDF[['n1']])
retDF['n2'] <- as.numeric(retDF[['n2']])
retDF['p1'] <- as.numeric(retDF[['p1']])
retDF['p2'] <- as.numeric(retDF[['p2']])
attr(retDF, "Ancestral_Allele") <- ancestralAllele
attr(retDF, "VariantID") <- attr(alleleDF, "VariantID")
fstVec <- numeric(nrow(retDF))
for(i in 1:nrow(retDF)){
fstVec[i] <- HudsonFst(retDF[i,2],retDF[i,4],retDF[i,3],retDF[i,5])
}
retDF['Fst_Hudson'] <- fstVec
return(retDF)
}
hudsonTest2 <- perAlleleFst_transform(perAllele_1, thousGenPops)
hudsonTest2 <- perAlleleFst_transform(perAllele_1, thousGenPops)
perAlleleFst_transform <- function(alleleDF, populations, deleteRedundants = FALSE){
# Extract data of interest from alleleDF
ancestralAllele <- attr(alleleDF, "Ancestral_Allele")
alleleDF <- alleleDF[alleleDF$population %in% populations$Population_Abbreviation & alleleDF$allele != ancestralAllele , ]
# Digest DF in to create DF out:
DF_rows <- nrow(alleleDF) # number for efficient pairwise iteration
rowHolder <- list()
for(i in 1:(DF_rows-1)){ # i correlates to a population
for(j in (1+i):DF_rows){ # j correlates to the second population used to pair with i's population
rName <- paste0(alleleDF$population[i], "-X-",alleleDF$population[j])
row <- c(rName,
populations[populations$Population_Abbreviation == alleleDF$population[i]]$Sample_Count,
alleleDF$frequency[i],
populations[populations$Population_Abbreviation == alleleDF$population[j]]$Sample_Count,
alleleDF$frequency[j])
rowHolder[[rName]] <- row
}
}
#setup return DF, name cols, fix col types, assign attributes
retDF <- as.data.frame(t(dplyr::bind_rows(rowHolder)))
names(retDF) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
retDF['n1'] <- as.numeric(retDF[['n1']])
retDF['n2'] <- as.numeric(retDF[['n2']])
retDF['p1'] <- as.numeric(retDF[['p1']])
retDF['p2'] <- as.numeric(retDF[['p2']])
attr(retDF, "Ancestral_Allele") <- ancestralAllele
attr(retDF, "VariantID") <- attr(alleleDF, "VariantID")
fstVec <- numeric(nrow(retDF))
for(i in 1:nrow(retDF)){
fstVec[i] <- HudsonFst(retDF[i,2],retDF[i,4],retDF[i,3],retDF[i,5])
}
retDF['Fst_Hudson'] <- fstVec
return(retDF)
}
debug(perAlleleFst_transform)
hudsonTest2 <- perAlleleFst_transform(perAllele_1, thousGenPops)
hudsonTest2 <- perAlleleFst_transform(perAllele_1, thousGenPops)
View(alleleDF)
View(alleleDF)
View(populations)
hudsonTest2 <- perAlleleFst_transform(perAllele_1, thousGenPops)
View(perAllele_1)
debug(perAlleleFst_transform)
hudsonTest2 <- perAlleleFst_transform(perAllele_1, thousGenPops)
hudsonTest2 <- perAlleleFst_transform(perAllele_1, thousGenPops)
View(rowHolder)
rowHolder[["1000GENOMES:phase_3:ACB-X-1000GENOMES:phase_3:AFR"]]
View(rowHolder)
rowHolder[["1000GENOMES:phase_3:ACB-X-1000GENOMES:phase_3:ALL"]]
View(alleleDF)
View(populations)
# no assignment should make for faster calculation on large data sets.
HudsonFst <- function(n1, n2, p1, p2){
return( ((p1-p2)**2 - (p1*(1-p1))/(n1-1) - (p2*(1-p2))/(n2-1)) / (p1*(1-p2) + p2*(1-p1)) )
}
tml <- testMasterList
perAllele_1 <- tml[[2]][[1]]
library(GWASpops.pheno2geno)
tml <- testMasterList
perAllele_1 <- tml[[2]][[1]]
populations <- Populations
thousGenPops <- populations[grep("1000GENOMES",populations$Population_Abbreviation)]
perAlleleFst_transform <- function(alleleDF, populations, deleteRedundants = FALSE){
# Extract data of interest from alleleDF
ancestralAllele <- attr(alleleDF, "Ancestral_Allele")
alleleDF <- alleleDF[alleleDF$population %in% populations$Population_Abbreviation & alleleDF$allele != ancestralAllele , ]
# Digest DF in to create DF out:
DF_rows <- nrow(alleleDF) # number for efficient pairwise iteration
rowHolder <- list()
for(i in 1:(DF_rows-1)){ # i correlates to a population
for(j in (1+i):DF_rows){ # j correlates to the second population used to pair with i's population
rName <- paste0(alleleDF$population[i], "-X-",alleleDF$population[j])
row <- c(rName,
populations[populations$Population_Abbreviation == alleleDF$population[i]]$Sample_Count,
alleleDF$frequency[i],
populations[populations$Population_Abbreviation == alleleDF$population[j]]$Sample_Count,
alleleDF$frequency[j])
rowHolder[[rName]] <- row
}
}
#setup return DF, name cols, fix col types, assign attributes
retDF <- as.data.frame(t(dplyr::bind_rows(rowHolder)))
names(retDF) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
retDF['n1'] <- as.numeric(retDF[['n1']])
retDF['n2'] <- as.numeric(retDF[['n2']])
retDF['p1'] <- as.numeric(retDF[['p1']])
retDF['p2'] <- as.numeric(retDF[['p2']])
attr(retDF, "Ancestral_Allele") <- ancestralAllele
attr(retDF, "VariantID") <- attr(alleleDF, "VariantID")
fstVec <- numeric(nrow(retDF))
for(i in 1:nrow(retDF)){
fstVec[i] <- HudsonFst(retDF[i,2],retDF[i,4],retDF[i,3],retDF[i,5])
}
retDF['Fst_Hudson'] <- fstVec
return(retDF)
}
hudsonTest2 <- perAlleleFst_transform(perAllele_1, thousGenPops)
View(hudsonTest2)
less <- hudsonTest2[,c(1,6)]
perAlleleFst_transform <- function(alleleDF, populations, deleteRedundants = FALSE){
# Extract data of interest from alleleDF
ancestralAllele <- attr(alleleDF, "Ancestral_Allele")
alleleDF <- alleleDF[alleleDF$population %in% populations$Population_Abbreviation & alleleDF$allele != ancestralAllele , ]
# Digest DF in to create DF out:
DF_rows <- nrow(alleleDF) # number for efficient pairwise iteration
rowHolder <- list()
for(i in 1:(DF_rows-1)){ # i correlates to a population
for(j in (1+i):DF_rows){ # j correlates to the second population used to pair with i's population
rName <- paste0(alleleDF$population[i], "-X-",alleleDF$population[j])
row <- c(rName,
populations[populations$Population_Abbreviation == alleleDF$population[i]]$Sample_Count,
alleleDF$frequency[i],
populations[populations$Population_Abbreviation == alleleDF$population[j]]$Sample_Count,
alleleDF$frequency[j])
rowHolder[[rName]] <- row
}
}
#setup return DF, name cols, fix col types, assign attributes
retDF <- as.data.frame(t(dplyr::bind_rows(rowHolder)))
names(retDF) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
retDF['n1'] <- as.numeric(retDF[['n1']])
retDF['n2'] <- as.numeric(retDF[['n2']])
retDF['p1'] <- as.numeric(retDF[['p1']])
retDF['p2'] <- as.numeric(retDF[['p2']])
attr(retDF, "Ancestral_Allele") <- ancestralAllele
attr(retDF, "VariantID") <- attr(alleleDF, "VariantID")
fstVec <- numeric(nrow(retDF))
for(i in 1:nrow(retDF)){
fstVec[i] <- HudsonFst(retDF[i,2],retDF[i,4],retDF[i,3],retDF[i,5])
}
retDF['Fst_Hudson'] <- fstVec
if(deleteRedundants){ #removing all but population pairs and Fst value to save memory
retDF <- retDF[,c(1,6)]
}
return(retDF)
}
