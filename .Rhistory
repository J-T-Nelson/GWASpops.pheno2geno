colnames(fstPer)
# seeing same issue... getting 528 pop-pairs.. which is 30 extra.. gotta figure out what is going wrong.
debug(tranform_fst_save)
# seeing same issue... getting 528 pop-pairs.. which is 30 extra.. gotta figure out what is going wrong.
debug(transform_fst_save)
testRun_2 <- transform_fst_save(asso, 1, 1, thousGenPops, TRUE, TRUE)
sapply(which.max(fstList))
sapply(fstList, which.max)
which.max(sapply(fstList, nrow))
badRow <- fstList[235]
View(badRow)
inspect <- masterList[[2]]['rsrs9692804']
View(inspect)
badRow[["rs9692804"]][["Fst_Hudson"]][1:100]
inspect <- masterList[[2]]['rs9692804']
View(inspect)
inspect$rs9692804$allele
unique(inspect$rs9692804$allele)
unique(inspect$rs9692804$population)
debug(perAlleleFst_transform)
perAlleleFst_transform(inspect$rs9692804)
View(alleleDF)
a <- c('A', 'G')
'C' %in% a
View(testRun_2)
perAlleleFst_transform <- function(alleleDF, populations, deleteRedundants = FALSE){
if(length(unique(alleleDF$allele)) > 2){ # no calculations for multiallelic sites. This method of Fst calculation isn't suitable to non-biallelic sites.
return(NA)
}
# Extract data of interest from alleleDF
ancestralAllele <- attr(alleleDF, "Ancestral_Allele")
if(is.na(ancestralAllele)){ # sometimes ancestral Allele is NA, which makes the rest of this function impossible to execute. Calculating ancestral allele by finding allele with highest frequency.
ancestralAllele <- calc_ancestralAllele(alleleDF)
}
if( !(ancestralAllele %in% unique(alleleDF$allele)) ) { # reassign AA if assignment of AA is somehow wrong, (ancestral allele not found in data.frame)
ancestralAllele <- calc_ancestralAllele(alleleDF)     #  Wrong assignment can come directly from data sources, not necessarily my own code
}
alleleDF <- alleleDF[alleleDF$population %in% populations$Population_Abbreviation & alleleDF$allele != ancestralAllele , ]
# Digest DF in to create DF out:
DF_rows <- nrow(alleleDF) # number for efficient pairwise iteration
if(DF_rows == 0){ # when no pops of interest exist for a given variant, we just cancel the function and return nothing
return(NULL)
}
rowHolder <- list()
for(i in 1:(DF_rows-1)){ # i correlates to a population
for(j in (1+i):DF_rows){ # j correlates to the second population used to pair with i's population
rName <- paste0(alleleDF$population[i], "-X-",alleleDF$population[j])
row <- c(rName,
populations[populations$Population_Abbreviation == alleleDF$population[i]]$Sample_Count,
alleleDF$frequency[i],
populations[populations$Population_Abbreviation == alleleDF$population[j]]$Sample_Count,
alleleDF$frequency[j])
rowHolder[[rName]] <- row
}
}
#setup return DF, name cols, fix col types, assign attributes
retDF <- as.data.frame(t(dplyr::bind_rows(rowHolder)))
names(retDF) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
retDF['n1'] <- as.numeric(retDF[['n1']])
retDF['n2'] <- as.numeric(retDF[['n2']])
retDF['p1'] <- as.numeric(retDF[['p1']])
retDF['p2'] <- as.numeric(retDF[['p2']])
attr(retDF, "Ancestral_Allele") <- ancestralAllele
attr(retDF, "VariantID") <- attr(alleleDF, "VariantID")
fstVec <- numeric(nrow(retDF))
for(i in 1:nrow(retDF)){
fstVec[i] <- HudsonFst(retDF[i,2],retDF[i,4],retDF[i,3],retDF[i,5])
}
retDF['Fst_Hudson'] <- fstVec
if(deleteRedundants){ #removing all but population pairs and Fst value to save memory, populations pairs are stored as row names
retDF <- retDF[,6, drop = FALSE] # drop = FALSE ensures we don't lose the row names in coercion
}
return(retDF)
}
undebug(transform_fst_save)
# found an entry with an ancestral allele that didn't match to alleles within the data frame.. Which breaks our system.. reset based on calc_ancestralAllele() ... if its possible to have an ancestral allele which is different from ANY found within a population (which I presume is in fact possible), then maybe I should change this code somehow.. but this is my fix for now.
testRun_3 <- transform_fst_save(asso, 1, 1, thousGenPops, TRUE, TRUE)
View(testRun_3)
# seeing same issue... getting 528 pop-pairs.. which is 30 extra.. gotta figure out what is going wrong.
debug(transform_fst_save)
# found an entry with an ancestral allele that didn't match to alleles within the data frame.. Which breaks our system.. reset based on calc_ancestralAllele() ... if its possible to have an ancestral allele which is different from ANY found within a population (which I presume is in fact possible), then maybe I should change this code somehow.. but this is my fix for now.
testRun_3 <- transform_fst_save(asso, 1, 1, thousGenPops, TRUE, TRUE) # again too many pop-pairs, 524 this time though..
which.max(sapply(fstList, nrow))
inspect <- masterList[[2]]['rs35995659']
View(inspect)
inspect <- masterList[[2]][['rs35995659']]
View(inspect)
attributes(inspect)
unique(inspect$allele)
debug(perAlleleFst_transform)
perAlleleFst_transform(inspect)
calc_ancestralAllele <- function(population_alleleDF){
alleleSet <- unique(population_alleleDF$allele)
highestSum <- 0
AA <- ''
for(allele_character in alleleSet){
tempSum <- population_alleleDF[population_alleleDF$allele == allele_character, ]$frequency
if(tempSum > highestSum){
highestSum <- tempSum
AA <- allele_character
}
}
return(AA)
}
View(calc_ancestralAllele)
calc_ancestralAllele <- function(population_alleleDF){
alleleSet <- unique(population_alleleDF$allele)
highestSum <- 0
AA <- ''
for(allele_character in alleleSet){
tempSum <- sum(population_alleleDF[population_alleleDF$allele == allele_character, ]$frequency)
if(tempSum > highestSum){
highestSum <- tempSum
AA <- allele_character
}
}
return(AA)
}
testRun_4 <- transform_fst_save(asso, 1, 1, thousGenPops, TRUE, TRUE) # want to see if calc_ancestralAllele works now...
library(GWASpops.pheno2geno)
testRun_4 <- transform_fst_save(asso, 1, 1, thousGenPops, TRUE, TRUE) # want to see if calc_ancestralAllele works now...
View(testRun_4)
attributes(testRun_4$Fst_per_allele[[1]])
attributes(testRun_4$Fst_per_allele[1])
#
calc_ancestralAllele <- function(population_alleleDF){
A_mag <- sum(population_alleleDF[population_alleleDF$allele == "A", ]$frequency)
C_mag <- sum(population_alleleDF[population_alleleDF$allele == "C", ]$frequency)
G_mag <- sum(population_alleleDF[population_alleleDF$allele == "G", ]$frequency)
T_mag <- sum(population_alleleDF[population_alleleDF$allele == "T", ]$frequency)
tempVec <- c(A_mag, C_mag, G_mag, T_mag)
ancestralAllele <- switch(which.max(tempVec),
'1' = "A",
'2' = "C",
'3' = "G",
'4' = "T")
return(ancestralAllele)
}
# found an entry with an ancestral allele that didn't match to alleles within the data frame.. Which breaks our system.. reset based on calc_ancestralAllele() ... if its possible to have an ancestral allele which is different from ANY found within a population (which I presume is in fact possible), then maybe I should change this code somehow.. but this is my fix for now.
testRun_3 <- transform_fst_save(asso, 1, 1, thousGenPops, TRUE, TRUE) # again too many pop-pairs, 524 this time though..
View(testRun_3)
which.max(sapply(testRun_3$Fst_per_allele, nrow))
sapply(testRun_3$Fst_per_allele, nrow)
View(calc_ancestralAllele)
# seeing same issue... getting 528 pop-pairs.. which is 30 extra.. gotta figure out what is going wrong.
debug(transform_fst_save)
# found an entry with an ancestral allele that didn't match to alleles within the data frame.. Which breaks our system.. reset based on calc_ancestralAllele() ... if its possible to have an ancestral allele which is different from ANY found within a population (which I presume is in fact possible), then maybe I should change this code somehow.. but this is my fix for now.
testRun_3 <- transform_fst_save(asso, 1, 1, thousGenPops, TRUE, TRUE) # again too many pop-pairs, 524 this time though..
which.max(sapply(fstList, nrow))
calc_ancestralAllele <- function(population_alleleDF){
alleleSet <- unique(population_alleleDF$allele)
highestSum <- 0
AA <- ''
for(allele_character in alleleSet){
tempSum <- sum(population_alleleDF[population_alleleDF$allele == allele_character, ]$frequency)
if(tempSum > highestSum){
highestSum <- tempSum
AA <- allele_character
}
}
return(AA)
}
testMany_1 <- transform_fst_save(asso,10,2,thousGenPops, TRUE,TRUE)
undebug(transform_fst_save)
testMany_1 <- transform_fst_save(asso,10,2,thousGenPops, TRUE,TRUE)
testMany_1 <- transform_fst_save(asso,10, 1,thousGenPops, TRUE, TRUE)
View(testMany_1)
load_n_flatten <- function(numChunks, startSuperChunk = 1) {
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\unprocessedChunks")
ret_list <- list()
for(i in 1:numChunks){
s <- i + (startSuperChunk-1)*100
end <- s + 99
dataName <- paste0("chunk", s, "-", end, ".rds")
load(dataName)
ret_list[[dataName]] <- retList
}
ret_list <- purrr::flatten(ret_list)
ret_list <- purrr::flatten(ret_list)
return(ret_list)
}
# transform_fst_save() takes in the large GWAS association table, a number of chunks, and starting chunk and transforms the lists within the chunks into a list of DFs and lists OF DFs.. 4 objects specified above. Fst will be calculated within then the object will be saved.
transform_fst_save <- function(GWAS_associations,
numChunks,
startChunk = 1,
Fst_populations,
return_DS = FALSE,
saveData = TRUE){
# load data from memory and flatten for processing
variantList <- load_n_flatten(numChunks = numChunks, startSuperChunk = startChunk)
# compose list then tranform into GWASpops.geno2pheno masterList format
dataList <- list(GWAS_associations, variantList)
masterList <- ensListTransform_mod(dataList, TRUE)
# calculate Fst, delete redudant data vals, and discard multiallelic sites
fstList <- hudsonFst_alleleList(masterList[[2]], Fst_populations, TRUE,TRUE)
# make single table of Fst Value list, then bind to masterList data structure
fstList <- fill_rows(fstList) # making all sublists compatible for binding together as data.frame
names <- names(fstList)
fstDF <- cbind.data.frame(fstList)
colnames(fstDF) <- names
fstDF <- as.data.frame(t(fstDF)) # transpose s.t. rows are alleles, cols are population-pairs
masterList[['Fst_per_allele']] <- fstDF
# save new data structure in memory
if(saveData){
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\fst_GWAS_annotation_lists")
fileName <- paste0('fullData_', numChunks, '_', startChunk)
save(masterList, file = fileName)
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno")
}
# return nothing if desired, or resulting data structure if desired.
if(return_DS){
return(masterList)
} else{
return()
}
}
# transform_fst_save() takes in the large GWAS association table, a number of chunks, and starting chunk and transforms the lists within the chunks into a list of DFs and lists OF DFs.. 4 objects specified above. Fst will be calculated within then the object will be saved.
transform_fst_save <- function(GWAS_associations,
numChunks,
startChunk = 1,
Fst_populations,
return_DS = FALSE,
saveData = TRUE){
# load data from memory and flatten for processing
variantList <- load_n_flatten(numChunks = numChunks, startSuperChunk = startChunk)
# compose list then tranform into GWASpops.geno2pheno masterList format
dataList <- list(GWAS_associations, variantList)
masterList <- ensListTransform_mod(dataList, TRUE)
# calculate Fst, delete redudant data vals, and discard multiallelic sites
fstList <- hudsonFst_alleleList(masterList[[2]], Fst_populations, deleteRedundants = TRUE, discardMultiAllelic =  TRUE)
# make single table of Fst Value list, then bind to masterList data structure
fstList <- fill_rows(fstList) # making all sublists compatible for binding together as data.frame
names <- names(fstList)
fstDF <- cbind.data.frame(fstList)
colnames(fstDF) <- names
fstDF <- as.data.frame(t(fstDF)) # transpose s.t. rows are alleles, cols are population-pairs
masterList[['Fst_per_allele']] <- fstDF
# save new data structure in memory
if(saveData){
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\fst_GWAS_annotation_lists")
fileName <- paste0('fullData_', numChunks, '_', startChunk)
save(masterList, file = fileName)
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno")
}
# return nothing if desired, or resulting data structure if desired.
if(return_DS){
return(masterList)
} else{
return()
}
}
testMany_1 <- transform_fst_save(asso, 10, 1,thousGenPops, TRUE, TRUE) # this call had an issue where the calculation of Fst only seemed to happen for the first chunk loaded. Gotta see why.
testMany_1 <- transform_fst_save(asso, 10, 1,thousGenPops, TRUE, TRUE) # this call had an issue where the calculation of Fst only seemed to happen for the first chunk loaded. Gotta see why.
View(load_n_flatten)
debug(transform_fst_save)
testMany_1 <- transform_fst_save(asso, 10, 1,thousGenPops, TRUE, TRUE) # this call had an issue where the calculation of Fst only seemed to happen for the first chunk loaded. Gotta see why.
load_n_flatten <- function(numChunks, startSuperChunk = 1) {
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\unprocessedChunks")
ret_list <- list()
startPoint <- (startSuperChunk - 1)*100 + 1
for(i in 1:numChunks){
s <- startPoint + (i-1)*100
end <- s + 99
dataName <- paste0("chunk", s, "-", end, ".rds")
load(dataName)
ret_list[[dataName]] <- retList
}
ret_list <- purrr::flatten(ret_list)
ret_list <- purrr::flatten(ret_list)
return(ret_list)
}
# transform_fst_save() takes in the large GWAS association table, a number of chunks, and starting chunk and transforms the lists within the chunks into a list of DFs and lists OF DFs.. 4 objects specified above. Fst will be calculated within then the object will be saved.
transform_fst_save <- function(GWAS_associations,
numChunks,
startChunk = 1,
Fst_populations,
return_DS = FALSE,
saveData = TRUE){
# load data from memory and flatten for processing
variantList <- load_n_flatten(numChunks = numChunks, startSuperChunk = startChunk)
# compose list then tranform into GWASpops.geno2pheno masterList format
dataList <- list(GWAS_associations, variantList)
masterList <- ensListTransform_mod(dataList, TRUE)
# calculate Fst, delete redudant data vals, and discard multiallelic sites
fstList <- hudsonFst_alleleList(masterList[[2]], Fst_populations, deleteRedundants = TRUE, discardMultiAllelic =  TRUE)
# make single table of Fst Value list, then bind to masterList data structure
fstList <- fill_rows(fstList) # making all sublists compatible for binding together as data.frame
names <- names(fstList)
fstDF <- cbind.data.frame(fstList)
colnames(fstDF) <- names
fstDF <- as.data.frame(t(fstDF)) # transpose s.t. rows are alleles, cols are population-pairs
masterList[['Fst_per_allele']] <- fstDF
# save new data structure in memory
if(saveData){
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\fst_GWAS_annotation_lists")
fileName <- paste0('fullData_', numChunks, '_', startChunk)
save(masterList, file = fileName)
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno")
}
# return nothing if desired, or resulting data structure if desired.
if(return_DS){
return(masterList)
} else{
return()
}
}
testMany_1 <- transform_fst_save(asso, 10, 1,thousGenPops, TRUE, TRUE)
testMany_1 <- transform_fst_save(asso, 10, 2,thousGenPops, TRUE, TRUE)
View(testRun_3)
View(testMany_1)
# it runs.. still not getting the num of Fst calcs we should see....
rownames(testMany_1[[4]])
testMany_2 <- transform_fst_save(asso, 3, 20, thousGenPops, TRUE, TRUE)
warnings()
View(testMany_2)
fst_ret <- testMany_2[[4]]
View(fst_ret)
max_hudson <- max(as.matrix(fstPer))
max_hudson
max_hudson # NA ... ok that is just not helpful at all. why woudl this be a thing lol?
?max
max_hudson <- max(as.matrix(fstPer), na.rm = TRUE)
min_hudson <- min(as.matrix(fstPer), na.rm=T)
max_hudson # NA ... ok that is just not helpful at all. why woudl this be a thing lol?
min_hudson
testMany_3 <- transform_fst_save(asso, 5, 1, thousGenPops, TRUE, TRUE)
debug(transform_fst_save) # debugging to see what the heck is going on inside
testMany_3 <- transform_fst_save(asso, 5, 1, thousGenPops, TRUE, TRUE)
View(variantList)
View(masterList)
View(fstList)
View(variantList)
View(masterList)
popAlleleList <- masterList[[2]]
indexMulti <- sapply(popAlleleList, \(x) length(unique(x$allele)))
indexMultii <- which(indexMulti > 2 )
indexBi <- which(indexMulti < 3)
indexBi <- which(indexMulti = 2)
indexBi <- which(indexMulti == 2)
indexBi <- which(indexMulti < 3)
indexBi <- which(indexMulti == 0)
indexBi <- which(indexMulti == 1)
indexBi
indexBi <- which(indexMulti == 2)
paList <- popAlleleList[indexBi]
thousGenPops <- Populations[grep("1000GENOMES", Populations$Population_Abbreviation)]
View(paList)
paList[[1]]$population %in% thousGenPops
paList[["rs10430743"]][["population"]]
View(thousGenPops)
thousGenPops$Population_Abbreviation
thousGenPops %in% paList[[1]]$population
thousGenPops$Population_Abbreviation %in% paList[[1]]$population
hasPops <- sapply(paList, \(x) sum(thousGenPops$Population_Abbreviation %in% x$population))
hasPopsTot <- hasPops[hasPops > 0 ]
hasPops
unique(hasPopsTot)
fullFlatten <- load_n_flatten(100)
View(allrsID_ch10)
names <- names(fullFlatten)
rm(fullFlatten)
fullFlatten2 <- load_n_flatten(99, 101)
names2 <- names(fullFlatten2)
rm(fullFlatten2)
fullFlatten3 <- load_n_flatten(33, 201)
names3 <- names(fullFlatten3)
rm(fullFlatten3)
allNames <- append(names, names2, names3)
allNames <- append(names, c(names2, names3))
uniqueNames <- unique(allNames)
207839/220866
dupeIndex <- which(duplicated(allNames))
?range
range(dupeIndex)
# Create a vector of indices
indices <- c(10, 5000, 100000, 200000, 219999)
# Create a vector of values
values <- runif(220000, min = 0, max = 1)
# Plot the values at the specified indices
plot(indices, values[indices], pch = 19, col = "blue", xlab = "Index", ylab = "Value")
plot(dupeIndex)
hist(dupeIndex)
# Create a vector of indices
indices <- 1:220000
# Create a binary vector indicating presence or absence of values
presence <- ifelse(indices %in% dupeIndex, 1, 0)
# Plot the presence of values at each index
plot(indices, presence, pch = 19, col = "blue", xlab = "Index", ylab = "Presence")
dupeList <- split(dupeIndex,ceiling( seq_along(dupeIndex)/1000 ))
View(dupeList)
dupeList[["1"]]
dupeList[["2"]]
dupeList[["14"]]
dupeList[["13"]]
dupeList[["14"]]
dupeList2 <- split(dupeIndex, 14)
View(dupeList2)
ceiling( seq_along(dupeIndex)/1000 )
seq_along(dupeIndex)/1000
seq_along(dupeIndex)
?ifelse
dupeList[["13"]]
dupeList[["14"]]
getPopsData <- function(rsIDChunkList, nChunks, startingChunk, reportNumErrors = TRUE){
retList <- list()
for (i in 1:nChunks){
chunk <- (startingChunk + i - 1)
chnkName <- paste0("Chunk_", chunk, "_CONT")
retList[[chnkName]] <- tryCatch(
expr = {
GWASpops.pheno2geno:::get_ensVariants(rsIDChunkList[[chunk]], population_data = TRUE)
},
error = function(e){
warning(paste0("Error occured for ", chnkName))
return(chnkName) # this should just return a character vector instead of a list which will be our means of identifying error counts
}
)
}
fileName <- paste0("chunk", startingChunk, "-", (startingChunk+nChunks-1) , ".rds")
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\unprocessedChunks")
save(retList, file = fileName)
setwd("../")
if(reportNumErrors){
numErrors <- sum(sapply(retList, is.character))
message(paste0("Number of empty chunks returned: ", numErrors))
message("\nEmpty chunks are returned as character vectors when an error is caught, or when the API fails to return expected data.\n")
}
return(retList)
}
grabChunks <- function(data, StartChunk = 1,chunksPerCall = 100, numCalls = 240){
#numCalls at default of 240 should mean that by default this would just call for all of the data
allrsID_ch10 <- data
for(i in 1:numCalls){
startPoint <- (StartChunk + (i - 1)*chunksPerCall) # incrementally updates starting chunk relative to starting point
if(startPoint > 23300){
message("All chunks should be grabbed except the last few")
return()
}
getPopsData(allrsID_ch10, nChunks = chunksPerCall, startPoint, reportNumErrors = FALSE)
}
message("call finished without automatic termination; i.e. not all chunks grabbed yet, but specified amount should be saved.")
return()
}
View(grabChunks)
grabChunks(allrsID_ch10, StartChunk = 2, numCalls = 15) # re-grabbing duplicated data
grabChunks(allrsID_ch10, StartChunk = 401, numCalls = 13) # calls froze...
getPopsData <- function(rsIDChunkList, nChunks, startingChunk, reportNumErrors = TRUE){
retList <- list()
for (i in 1:nChunks){
chunk <- (startingChunk + i - 1)
chnkName <- paste0("Chunk_", chunk, "_CONT")
retList[[chnkName]] <- tryCatch(
expr = {
GWASpops.pheno2geno:::get_ensVariants(rsIDChunkList[[chunk]], population_data = TRUE)
},
error = function(e){
warning(paste0("Error occured for ", chnkName))
return(chnkName) # this should just return a character vector instead of a list which will be our means of identifying error counts
}
)
}
fileName <- paste0("chunk", startingChunk, "-", (startingChunk+nChunks-1) , ".rds")
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\unprocessedChunks")
save(retList, file = fileName)
setwd("../")
if(reportNumErrors){
numErrors <- sum(sapply(retList, is.character))
message(paste0("Number of empty chunks returned: ", numErrors))
message("\nEmpty chunks are returned as character vectors when an error is caught, or when the API fails to return expected data.\n")
}
return(retList)
}
grabChunks <- function(data, StartChunk = 1,chunksPerCall = 100, numCalls = 240){
#numCalls at default of 240 should mean that by default this would just call for all of the data
allrsID_ch10 <- data
for(i in 1:numCalls){
startPoint <- (StartChunk + (i - 1)*chunksPerCall) # incrementally updates starting chunk relative to starting point
if(startPoint > 23300){
message("All chunks should be grabbed except the last few")
return()
}
getPopsData(allrsID_ch10, nChunks = chunksPerCall, startPoint, reportNumErrors = FALSE)
}
message("call finished without automatic termination; i.e. not all chunks grabbed yet, but specified amount should be saved.")
return()
}
grabChunks(allrsID_ch10, StartChunk = 401, numCalls = 13) # calls froze...
fullFlatten <- load_n_flatten(15)
View(fullFlatten)
namesFF <- names(fullFlatten)
uNamesFF <- unique(namesFF)
dupeIndex2 <- which(duplicated(uNamesFF))
dupeIndex2 <- which(duplicated(NamesFF))
dupeIndex2 <- which(duplicated(namesFF))
dupeIndex2
fullFlatten_22 <- load_n_flatten(20)
namesFF22 <- names(fullFlatten) # 14572
uNamesFF22 <- unique(namesFF) # 13590 .... more duplication than I want.. something like 1 whole chunk... but not bad.
dupeIndex22 <- which(duplicated(namesFF))
dupeIndex22
grabChunks(allrsID_ch10, StartChunk = 1701, numCalls = 4) # will take like 2 hrs I think..
fullFlatten_22 <- load_n_flatten(20)
namesFF22 <- names(fullFlatten)
namesFF22 <- names(fullFlatten_22)
uNamesFF22 <- unique(namesFF22)
dupeIndex22 <- which(duplicated(namesFF22))
dupeIndex22
testMany_5 <- transform_fst_save(asso, 5, 2, thousGenPops, TRUE, TRUE)
library(GWASpops.pheno2geno)
testMany_5 <- transform_fst_save(asso, 5, 2, thousGenPops, TRUE, TRUE) # going to test this call to see if # fst out is closer to what is expected. ... we don't want to see 733 again.
13/417
View(testMany_5)
