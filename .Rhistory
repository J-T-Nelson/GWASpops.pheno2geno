names <- names(fstList)
fstDF <- cbind.data.frame(fstList)
colnames(fstDF) <- names
fstDF <- as.data.frmae(t(fstDF)) # transpose s.t. rows are alleles, cols are population-pairs
masterList[['Fst_per_allele']] <- fstDF
# save new data structure in memory
if(saveData){
fileName <- paste0("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\fst_GWAS_annotation_lists",'fullData_', numChunks, '_', startChunk)
save(masterList, file = fileName)
}
# return nothing if desired, or resulting data structure if desired.
if(return_DS){
return(masterList)
} else{
return()
}
}
testRun_1 <- transform_fst_save(asso, 1, 1, thousGenPops, TRUE, TRUE)
testRun_1 <- transform_fst_save(asso, 1, 1, thousGenPops, TRUE, TRUE)
asso[['SNPS']]
asso[[VariantID]]
asso[['VariantID']][1:10]
#'
#'
#' @param dataList Data to be transformed. Must be in list format such that a GWAS data table is the first element and the respective data produced from calling Ensembl's REST API Variants endpoint with get_ensVariants() is the second element within the list. Position in the list is critical to successful execution of this function
#' @param popsData populations data transformation option. when TRUE function runs assuming variants from Ensembl REST API have been called with populations option activated, resulting output is different due to this extra population data.
#'
#' @return data.frame or list of data.frames
#'
#' @examples NA
#'
#' @export
ensListTransform_mod <- function(dataList, popsData = F) {
# dataList is a list with 2 elements, dataList[[1]] = GWAS data table ; dataList[[2]] = Ensembl API data in R list form
if(!requireNamespace("GWASpops.pheno2geno", quietly = TRUE)){
library(GWASpops.pheno2geno)
}
Populations <- Populations
#CONT <- purrr::flatten(dataList[[2]]) #removing nested structure such that all sublists are combined into one list within dataList[[2]]
CONT <- dataList[[2]]
CONT <- purrr::compact(CONT) # removing empty elements introduced by:
## multiAPIcall_variants2 (?)... I think its one of the for loops that are fixing these data elements: EnsVar_synonyms and EnsVar_Clinical_significance.
GWAS_DF <- dataList[[1]] #storing GWAS data from GWAS files for later.. (similar to createMT())
if(is.null(GWAS_DF[['VariantID']])){ # renaming col for compatibility of pipeline functions
data.table::setnames(GWAS_DF, old = 'SNPS', new = 'VariantID')
}
if(popsData){
# grabbing population data and converting into a list of tibbles.
popData <- sapply(CONT, function(x) x$populations) #OPTIMIZATION: this may be more efficient with masking.. not sure though
popData <- lapply(popData, function(x) dplyr::bind_rows(x)) # OPTIMIZATION: check if this can run without the anonymous function in lapply() .. I imagine its increasing operations for this call.
# removes populations from the response content so further operations proceed properly.
CONT <- lapply(CONT, function(x) x[names(x) != 'populations']) # OPTIMIZATION: Check for function which removes and returns elements from lists... as this call may removed if the original popData <- sapply() call removed and returned
}
# removing multimapping by flattening the lists out. (some rsIDs posses multiple mappings against the reference genome(?) or against different data within Ensembl's API databases(?) )
CONT <- GWASpops.pheno2geno:::fixMultiMapping(CONT)
CONT <- CONT[!sapply(CONT, is.null)] # this is a quick and dirty solution to the fact that fixMultiMapping() is producing null list entries at the end of its list output. I don't know why this is happening. OPTIMIZATION: DEBUG THE ISSUE MENTIONED IN THIS LINE FOR fixMultiMapping()  .... OPTIMIZATION 2: look to the comment below about $failed mappings being introduced occassionally, check for them within fixMultiMapping if possible and remove the need for additional code out here.
# infrequently a `$failed` key:value pair is being introduced into lists after flattening out mappings, this indicates that a mapping doesn't map to the reference genome in Ensembl's data base, thus we are removing such entries.
hasFailed <- sapply(CONT, \(x) rlang::has_name(x, "failed")) # MAKES Boolean mask
CONT <- CONT[!hasFailed] # USES Boolean mask to filter out entries with `failed` key:value pairs
CONT <- lapply(CONT, GWASpops.pheno2geno:::null2NA_ENSvariants)
CONT_Table <- GWASpops.pheno2geno:::rsTable(CONT) #CONT_Table at this point is just EnsVariants. No GWAS data or Pop data.
#renaming cols so their source is evident in the master table.
names(CONT_Table) <- paste0('EnsVar_',names(CONT_Table))
if(popsData){
# setting ancestral allele attribute on population frequency data.
popData <- GWASpops.pheno2geno:::AncestralAllele_attr(CONT_Table, popData)
masterList <- list(CONT_Table, popData)
# Merging Ensembl variant and GWAS data tables
masterTable <- tryCatch(
expr = {
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name')
},
error = function(e){ # in the case of too many duplicate rows causing the merge to
# fail initially this option will allow for the merge to proceed.
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name', allow.cartesian = T);
message("merge.data.table performed with `allow.cartesian = TRUE`, therefore many extra rows may be produced. Duplicated rows have been removed");
masterTable$EnsVar_synonyms <- as.character(masterTable$EnsVar_synonyms);
masterTable <- masterTable[!duplicated(masterTable)]; #removing many duplicated rows created.
return(masterTable)
}
)
# Transforming data for single population based data tables
singlePop_alleleFreqDTs <- lapply(Populations$Population_Abbreviation,
function(x) GWASpops.pheno2geno:::singlePopTransform(masterList[[2]], targetPopulation = x))
# Populations is a data object that comes with the package. (see ?Populations for more information or inspect the object itself.)
names(singlePop_alleleFreqDTs) <- Populations$Population_Abbreviation
masterListFinal <- list(masterTable, masterList[[2]], singlePop_alleleFreqDTs)
names(masterListFinal) <- c('masterTable', 'PopAlleleFreqData', 'singlePop_alleleFreqDTs')
return(masterListFinal) ######## END for pops
}
#------------- only variant data ------------------------
# Merging Ensembl variant and GWAS data tables
masterTable <- tryCatch(
expr = {
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name')
},
error = function(e){ # in the case of too many duplicate rows causing the merge to
# fail initially this option will allow for the merge to proceed.
masterTable <- data.table:::merge.data.table(GWAS_DF, CONT_Table, by.x = 'VariantID', by.y = 'EnsVar_name', allow.cartesian = T);
message("merge.data.table performed with `allow.cartesian = TRUE`, therefore many extra rows may be produced. Duplicated rows have been removed");
masterTable$EnsVar_synonyms <- as.character(masterTable$EnsVar_synonyms);
masterTable <- masterTable[!duplicated(masterTable)]; #removing many duplicated rows created.
return(masterTable)
}
)
return(masterTable) ######### END for vars
}
testRun_1 <- transform_fst_save(asso, 1, 1, thousGenPops, TRUE, TRUE)
# transform_fst_save() takes in the large GWAS association table, a number of chunks, and starting chunk and transforms the lists within the chunks into a list of DFs and lists OF DFs.. 4 objects specified above. Fst will be calculated within then the object will be saved.
transform_fst_save <- function(GWAS_associations,
numChunks,
startChunk = 1,
Fst_populations,
return_DS = FALSE,
saveData = TRUE){
# load data from memory and flatten for processing
variantList <- load_n_flatten(numChunks = numChunks, startChunk = startChunk)
# compose list then tranform into GWASpops.geno2pheno masterList format
dataList <- list(GWAS_associations, variantList)
masterList <- ensListTransform_mod(dataList, TRUE)
# calculate Fst, delete redudant data vals, and discard multiallelic sites
fstList <- hudsonFst_alleleList(masterList[[2]], Fst_populations, TRUE,TRUE)
# make single table of Fst Value list, then bind to masterList data structure
fstList <- fill_rows(fstList) # making all sublists compatible for binding together as data.frame
names <- names(fstList)
fstDF <- cbind.data.frame(fstList)
colnames(fstDF) <- names
fstDF <- as.data.frame(t(fstDF)) # transpose s.t. rows are alleles, cols are population-pairs
masterList[['Fst_per_allele']] <- fstDF
# save new data structure in memory
if(saveData){
fileName <- paste0("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\fst_GWAS_annotation_lists",'fullData_', numChunks, '_', startChunk)
save(masterList, file = fileName)
}
# return nothing if desired, or resulting data structure if desired.
if(return_DS){
return(masterList)
} else{
return()
}
}
testRun_1 <- transform_fst_save(asso, 1, 1, thousGenPops, TRUE, TRUE)
View(testRun_1)
View(perAlleleFst_transform)
source("bootCalls2.R")
load("./WorkingData/GwasAssocitions.rda")
library(GWASpops.pheno2geno)
source("./R/fst_funcs.R")
source("./workingScripts/dataTransform_Fst.R")
thousGenPops <- Populations[grep("1000GENOMES", Populations$Population_Abbreviation)]
testRun_2 <- transform_fst_save(asso, 1, 1, thousGenPops, TRUE, TRUE)
View(testRun_2)
fstPer <- testRun_2[[4]]
View(fstPer)
rownames(fstPer)
colnames(fstPer)
# seeing same issue... getting 528 pop-pairs.. which is 30 extra.. gotta figure out what is going wrong.
debug(tranform_fst_save)
# seeing same issue... getting 528 pop-pairs.. which is 30 extra.. gotta figure out what is going wrong.
debug(transform_fst_save)
testRun_2 <- transform_fst_save(asso, 1, 1, thousGenPops, TRUE, TRUE)
sapply(which.max(fstList))
sapply(fstList, which.max)
which.max(sapply(fstList, nrow))
badRow <- fstList[235]
View(badRow)
inspect <- masterList[[2]]['rsrs9692804']
View(inspect)
badRow[["rs9692804"]][["Fst_Hudson"]][1:100]
inspect <- masterList[[2]]['rs9692804']
View(inspect)
inspect$rs9692804$allele
unique(inspect$rs9692804$allele)
unique(inspect$rs9692804$population)
debug(perAlleleFst_transform)
perAlleleFst_transform(inspect$rs9692804)
View(alleleDF)
a <- c('A', 'G')
'C' %in% a
View(testRun_2)
perAlleleFst_transform <- function(alleleDF, populations, deleteRedundants = FALSE){
if(length(unique(alleleDF$allele)) > 2){ # no calculations for multiallelic sites. This method of Fst calculation isn't suitable to non-biallelic sites.
return(NA)
}
# Extract data of interest from alleleDF
ancestralAllele <- attr(alleleDF, "Ancestral_Allele")
if(is.na(ancestralAllele)){ # sometimes ancestral Allele is NA, which makes the rest of this function impossible to execute. Calculating ancestral allele by finding allele with highest frequency.
ancestralAllele <- calc_ancestralAllele(alleleDF)
}
if( !(ancestralAllele %in% unique(alleleDF$allele)) ) { # reassign AA if assignment of AA is somehow wrong, (ancestral allele not found in data.frame)
ancestralAllele <- calc_ancestralAllele(alleleDF)     #  Wrong assignment can come directly from data sources, not necessarily my own code
}
alleleDF <- alleleDF[alleleDF$population %in% populations$Population_Abbreviation & alleleDF$allele != ancestralAllele , ]
# Digest DF in to create DF out:
DF_rows <- nrow(alleleDF) # number for efficient pairwise iteration
if(DF_rows == 0){ # when no pops of interest exist for a given variant, we just cancel the function and return nothing
return(NULL)
}
rowHolder <- list()
for(i in 1:(DF_rows-1)){ # i correlates to a population
for(j in (1+i):DF_rows){ # j correlates to the second population used to pair with i's population
rName <- paste0(alleleDF$population[i], "-X-",alleleDF$population[j])
row <- c(rName,
populations[populations$Population_Abbreviation == alleleDF$population[i]]$Sample_Count,
alleleDF$frequency[i],
populations[populations$Population_Abbreviation == alleleDF$population[j]]$Sample_Count,
alleleDF$frequency[j])
rowHolder[[rName]] <- row
}
}
#setup return DF, name cols, fix col types, assign attributes
retDF <- as.data.frame(t(dplyr::bind_rows(rowHolder)))
names(retDF) <- c("pop_pair", 'n1', "p1", 'n2', 'p2')
retDF['n1'] <- as.numeric(retDF[['n1']])
retDF['n2'] <- as.numeric(retDF[['n2']])
retDF['p1'] <- as.numeric(retDF[['p1']])
retDF['p2'] <- as.numeric(retDF[['p2']])
attr(retDF, "Ancestral_Allele") <- ancestralAllele
attr(retDF, "VariantID") <- attr(alleleDF, "VariantID")
fstVec <- numeric(nrow(retDF))
for(i in 1:nrow(retDF)){
fstVec[i] <- HudsonFst(retDF[i,2],retDF[i,4],retDF[i,3],retDF[i,5])
}
retDF['Fst_Hudson'] <- fstVec
if(deleteRedundants){ #removing all but population pairs and Fst value to save memory, populations pairs are stored as row names
retDF <- retDF[,6, drop = FALSE] # drop = FALSE ensures we don't lose the row names in coercion
}
return(retDF)
}
undebug(transform_fst_save)
# found an entry with an ancestral allele that didn't match to alleles within the data frame.. Which breaks our system.. reset based on calc_ancestralAllele() ... if its possible to have an ancestral allele which is different from ANY found within a population (which I presume is in fact possible), then maybe I should change this code somehow.. but this is my fix for now.
testRun_3 <- transform_fst_save(asso, 1, 1, thousGenPops, TRUE, TRUE)
View(testRun_3)
# seeing same issue... getting 528 pop-pairs.. which is 30 extra.. gotta figure out what is going wrong.
debug(transform_fst_save)
# found an entry with an ancestral allele that didn't match to alleles within the data frame.. Which breaks our system.. reset based on calc_ancestralAllele() ... if its possible to have an ancestral allele which is different from ANY found within a population (which I presume is in fact possible), then maybe I should change this code somehow.. but this is my fix for now.
testRun_3 <- transform_fst_save(asso, 1, 1, thousGenPops, TRUE, TRUE) # again too many pop-pairs, 524 this time though..
which.max(sapply(fstList, nrow))
inspect <- masterList[[2]]['rs35995659']
View(inspect)
inspect <- masterList[[2]][['rs35995659']]
View(inspect)
attributes(inspect)
unique(inspect$allele)
debug(perAlleleFst_transform)
perAlleleFst_transform(inspect)
calc_ancestralAllele <- function(population_alleleDF){
alleleSet <- unique(population_alleleDF$allele)
highestSum <- 0
AA <- ''
for(allele_character in alleleSet){
tempSum <- population_alleleDF[population_alleleDF$allele == allele_character, ]$frequency
if(tempSum > highestSum){
highestSum <- tempSum
AA <- allele_character
}
}
return(AA)
}
View(calc_ancestralAllele)
calc_ancestralAllele <- function(population_alleleDF){
alleleSet <- unique(population_alleleDF$allele)
highestSum <- 0
AA <- ''
for(allele_character in alleleSet){
tempSum <- sum(population_alleleDF[population_alleleDF$allele == allele_character, ]$frequency)
if(tempSum > highestSum){
highestSum <- tempSum
AA <- allele_character
}
}
return(AA)
}
testRun_4 <- transform_fst_save(asso, 1, 1, thousGenPops, TRUE, TRUE) # want to see if calc_ancestralAllele works now...
library(GWASpops.pheno2geno)
testRun_4 <- transform_fst_save(asso, 1, 1, thousGenPops, TRUE, TRUE) # want to see if calc_ancestralAllele works now...
View(testRun_4)
attributes(testRun_4$Fst_per_allele[[1]])
attributes(testRun_4$Fst_per_allele[1])
#
calc_ancestralAllele <- function(population_alleleDF){
A_mag <- sum(population_alleleDF[population_alleleDF$allele == "A", ]$frequency)
C_mag <- sum(population_alleleDF[population_alleleDF$allele == "C", ]$frequency)
G_mag <- sum(population_alleleDF[population_alleleDF$allele == "G", ]$frequency)
T_mag <- sum(population_alleleDF[population_alleleDF$allele == "T", ]$frequency)
tempVec <- c(A_mag, C_mag, G_mag, T_mag)
ancestralAllele <- switch(which.max(tempVec),
'1' = "A",
'2' = "C",
'3' = "G",
'4' = "T")
return(ancestralAllele)
}
# found an entry with an ancestral allele that didn't match to alleles within the data frame.. Which breaks our system.. reset based on calc_ancestralAllele() ... if its possible to have an ancestral allele which is different from ANY found within a population (which I presume is in fact possible), then maybe I should change this code somehow.. but this is my fix for now.
testRun_3 <- transform_fst_save(asso, 1, 1, thousGenPops, TRUE, TRUE) # again too many pop-pairs, 524 this time though..
View(testRun_3)
which.max(sapply(testRun_3$Fst_per_allele, nrow))
sapply(testRun_3$Fst_per_allele, nrow)
View(calc_ancestralAllele)
# seeing same issue... getting 528 pop-pairs.. which is 30 extra.. gotta figure out what is going wrong.
debug(transform_fst_save)
# found an entry with an ancestral allele that didn't match to alleles within the data frame.. Which breaks our system.. reset based on calc_ancestralAllele() ... if its possible to have an ancestral allele which is different from ANY found within a population (which I presume is in fact possible), then maybe I should change this code somehow.. but this is my fix for now.
testRun_3 <- transform_fst_save(asso, 1, 1, thousGenPops, TRUE, TRUE) # again too many pop-pairs, 524 this time though..
which.max(sapply(fstList, nrow))
calc_ancestralAllele <- function(population_alleleDF){
alleleSet <- unique(population_alleleDF$allele)
highestSum <- 0
AA <- ''
for(allele_character in alleleSet){
tempSum <- sum(population_alleleDF[population_alleleDF$allele == allele_character, ]$frequency)
if(tempSum > highestSum){
highestSum <- tempSum
AA <- allele_character
}
}
return(AA)
}
testMany_1 <- transform_fst_save(asso,10,2,thousGenPops, TRUE,TRUE)
undebug(transform_fst_save)
testMany_1 <- transform_fst_save(asso,10,2,thousGenPops, TRUE,TRUE)
testMany_1 <- transform_fst_save(asso,10, 1,thousGenPops, TRUE, TRUE)
View(testMany_1)
load_n_flatten <- function(numChunks, startSuperChunk = 1) {
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\unprocessedChunks")
ret_list <- list()
for(i in 1:numChunks){
s <- i + (startSuperChunk-1)*100
end <- s + 99
dataName <- paste0("chunk", s, "-", end, ".rds")
load(dataName)
ret_list[[dataName]] <- retList
}
ret_list <- purrr::flatten(ret_list)
ret_list <- purrr::flatten(ret_list)
return(ret_list)
}
# transform_fst_save() takes in the large GWAS association table, a number of chunks, and starting chunk and transforms the lists within the chunks into a list of DFs and lists OF DFs.. 4 objects specified above. Fst will be calculated within then the object will be saved.
transform_fst_save <- function(GWAS_associations,
numChunks,
startChunk = 1,
Fst_populations,
return_DS = FALSE,
saveData = TRUE){
# load data from memory and flatten for processing
variantList <- load_n_flatten(numChunks = numChunks, startSuperChunk = startChunk)
# compose list then tranform into GWASpops.geno2pheno masterList format
dataList <- list(GWAS_associations, variantList)
masterList <- ensListTransform_mod(dataList, TRUE)
# calculate Fst, delete redudant data vals, and discard multiallelic sites
fstList <- hudsonFst_alleleList(masterList[[2]], Fst_populations, TRUE,TRUE)
# make single table of Fst Value list, then bind to masterList data structure
fstList <- fill_rows(fstList) # making all sublists compatible for binding together as data.frame
names <- names(fstList)
fstDF <- cbind.data.frame(fstList)
colnames(fstDF) <- names
fstDF <- as.data.frame(t(fstDF)) # transpose s.t. rows are alleles, cols are population-pairs
masterList[['Fst_per_allele']] <- fstDF
# save new data structure in memory
if(saveData){
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\fst_GWAS_annotation_lists")
fileName <- paste0('fullData_', numChunks, '_', startChunk)
save(masterList, file = fileName)
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno")
}
# return nothing if desired, or resulting data structure if desired.
if(return_DS){
return(masterList)
} else{
return()
}
}
# transform_fst_save() takes in the large GWAS association table, a number of chunks, and starting chunk and transforms the lists within the chunks into a list of DFs and lists OF DFs.. 4 objects specified above. Fst will be calculated within then the object will be saved.
transform_fst_save <- function(GWAS_associations,
numChunks,
startChunk = 1,
Fst_populations,
return_DS = FALSE,
saveData = TRUE){
# load data from memory and flatten for processing
variantList <- load_n_flatten(numChunks = numChunks, startSuperChunk = startChunk)
# compose list then tranform into GWASpops.geno2pheno masterList format
dataList <- list(GWAS_associations, variantList)
masterList <- ensListTransform_mod(dataList, TRUE)
# calculate Fst, delete redudant data vals, and discard multiallelic sites
fstList <- hudsonFst_alleleList(masterList[[2]], Fst_populations, deleteRedundants = TRUE, discardMultiAllelic =  TRUE)
# make single table of Fst Value list, then bind to masterList data structure
fstList <- fill_rows(fstList) # making all sublists compatible for binding together as data.frame
names <- names(fstList)
fstDF <- cbind.data.frame(fstList)
colnames(fstDF) <- names
fstDF <- as.data.frame(t(fstDF)) # transpose s.t. rows are alleles, cols are population-pairs
masterList[['Fst_per_allele']] <- fstDF
# save new data structure in memory
if(saveData){
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\fst_GWAS_annotation_lists")
fileName <- paste0('fullData_', numChunks, '_', startChunk)
save(masterList, file = fileName)
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno")
}
# return nothing if desired, or resulting data structure if desired.
if(return_DS){
return(masterList)
} else{
return()
}
}
testMany_1 <- transform_fst_save(asso, 10, 1,thousGenPops, TRUE, TRUE) # this call had an issue where the calculation of Fst only seemed to happen for the first chunk loaded. Gotta see why.
testMany_1 <- transform_fst_save(asso, 10, 1,thousGenPops, TRUE, TRUE) # this call had an issue where the calculation of Fst only seemed to happen for the first chunk loaded. Gotta see why.
View(load_n_flatten)
debug(transform_fst_save)
testMany_1 <- transform_fst_save(asso, 10, 1,thousGenPops, TRUE, TRUE) # this call had an issue where the calculation of Fst only seemed to happen for the first chunk loaded. Gotta see why.
load_n_flatten <- function(numChunks, startSuperChunk = 1) {
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\unprocessedChunks")
ret_list <- list()
startPoint <- (startSuperChunk - 1)*100 + 1
for(i in 1:numChunks){
s <- startPoint + (i-1)*100
end <- s + 99
dataName <- paste0("chunk", s, "-", end, ".rds")
load(dataName)
ret_list[[dataName]] <- retList
}
ret_list <- purrr::flatten(ret_list)
ret_list <- purrr::flatten(ret_list)
return(ret_list)
}
# transform_fst_save() takes in the large GWAS association table, a number of chunks, and starting chunk and transforms the lists within the chunks into a list of DFs and lists OF DFs.. 4 objects specified above. Fst will be calculated within then the object will be saved.
transform_fst_save <- function(GWAS_associations,
numChunks,
startChunk = 1,
Fst_populations,
return_DS = FALSE,
saveData = TRUE){
# load data from memory and flatten for processing
variantList <- load_n_flatten(numChunks = numChunks, startSuperChunk = startChunk)
# compose list then tranform into GWASpops.geno2pheno masterList format
dataList <- list(GWAS_associations, variantList)
masterList <- ensListTransform_mod(dataList, TRUE)
# calculate Fst, delete redudant data vals, and discard multiallelic sites
fstList <- hudsonFst_alleleList(masterList[[2]], Fst_populations, deleteRedundants = TRUE, discardMultiAllelic =  TRUE)
# make single table of Fst Value list, then bind to masterList data structure
fstList <- fill_rows(fstList) # making all sublists compatible for binding together as data.frame
names <- names(fstList)
fstDF <- cbind.data.frame(fstList)
colnames(fstDF) <- names
fstDF <- as.data.frame(t(fstDF)) # transpose s.t. rows are alleles, cols are population-pairs
masterList[['Fst_per_allele']] <- fstDF
# save new data structure in memory
if(saveData){
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno\\workingData\\fst_GWAS_annotation_lists")
fileName <- paste0('fullData_', numChunks, '_', startChunk)
save(masterList, file = fileName)
setwd("D:\\Programming\\R_projects\\Kulathinal_Lab\\GWASpops.pheno2geno")
}
# return nothing if desired, or resulting data structure if desired.
if(return_DS){
return(masterList)
} else{
return()
}
}
testMany_1 <- transform_fst_save(asso, 10, 1,thousGenPops, TRUE, TRUE)
testMany_1 <- transform_fst_save(asso, 10, 2,thousGenPops, TRUE, TRUE)
View(testRun_3)
View(testMany_1)
# it runs.. still not getting the num of Fst calcs we should see....
rownames(testMany_1[[4]])
testMany_2 <- transform_fst_save(asso, 3, 20, thousGenPops, TRUE, TRUE)
warnings()
View(testMany_2)
fst_ret <- testMany_2[[4]]
View(fst_ret)
max_hudson <- max(as.matrix(fstPer))
max_hudson
max_hudson # NA ... ok that is just not helpful at all. why woudl this be a thing lol?
?max
max_hudson <- max(as.matrix(fstPer), na.rm = TRUE)
min_hudson <- min(as.matrix(fstPer), na.rm=T)
max_hudson # NA ... ok that is just not helpful at all. why woudl this be a thing lol?
min_hudson
testMany_3 <- transform_fst_save(asso, 5, 1, thousGenPops, TRUE, TRUE)
debug(transform_fst_save) # debugging to see what the heck is going on inside
testMany_3 <- transform_fst_save(asso, 5, 1, thousGenPops, TRUE, TRUE)
View(variantList)
View(masterList)
View(fstList)
View(variantList)
View(masterList)
popAlleleList <- masterList[[2]]
indexMulti <- sapply(popAlleleList, \(x) length(unique(x$allele)))
indexMultii <- which(indexMulti > 2 )
indexBi <- which(indexMulti < 3)
indexBi <- which(indexMulti = 2)
indexBi <- which(indexMulti == 2)
indexBi <- which(indexMulti < 3)
indexBi <- which(indexMulti == 0)
indexBi <- which(indexMulti == 1)
indexBi
indexBi <- which(indexMulti == 2)
paList <- popAlleleList[indexBi]
thousGenPops <- Populations[grep("1000GENOMES", Populations$Population_Abbreviation)]
View(paList)
paList[[1]]$population %in% thousGenPops
paList[["rs10430743"]][["population"]]
View(thousGenPops)
thousGenPops$Population_Abbreviation
thousGenPops %in% paList[[1]]$population
thousGenPops$Population_Abbreviation %in% paList[[1]]$population
hasPops <- sapply(paList, \(x) sum(thousGenPops$Population_Abbreviation %in% x$population))
hasPopsTot <- hasPops[hasPops > 0 ]
hasPops
unique(hasPopsTot)
